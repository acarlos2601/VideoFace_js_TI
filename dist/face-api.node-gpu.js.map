{
  "version": 3,
  "sources": ["../src/tfjs/tf-node-gpu.ts", "../src/env/isNodejs.ts", "../src/index.ts", "../src/draw/index.ts", "../src/draw/drawContour.ts", "../src/utils/index.ts", "../src/classes/Dimensions.ts", "../src/classes/Point.ts", "../src/classes/Box.ts", "../src/classes/BoundingBox.ts", "../src/classes/ObjectDetection.ts", "../src/classes/FaceDetection.ts", "../src/ops/iou.ts", "../src/ops/minBbox.ts", "../src/ops/nonMaxSuppression.ts", "../src/ops/normalize.ts", "../src/ops/padToSquare.ts", "../src/ops/shuffleArray.ts", "../src/ops/index.ts", "../src/classes/Rect.ts", "../src/classes/FaceLandmarks.ts", "../src/classes/FaceLandmarks5.ts", "../src/classes/FaceLandmarks68.ts", "../src/classes/FaceMatch.ts", "../src/classes/LabeledBox.ts", "../src/classes/LabeledFaceDescriptors.ts", "../src/classes/PredictedBox.ts", "../src/factories/WithFaceDetection.ts", "../src/env/createBrowserEnv.ts", "../src/env/createFileSystem.ts", "../src/env/createNodejsEnv.ts", "../src/env/isBrowser.ts", "../src/env/index.ts", "../src/dom/resolveInput.ts", "../src/dom/getContext2dOrThrow.ts", "../src/draw/DrawTextField.ts", "../src/draw/DrawBox.ts", "../src/draw/drawDetections.ts", "../src/faceExpressionNet/FaceExpressionNet.ts", "../src/dom/isMediaLoaded.ts", "../src/dom/awaitMediaLoaded.ts", "../src/dom/bufferToImage.ts", "../src/dom/getMediaDimensions.ts", "../src/dom/createCanvas.ts", "../src/dom/imageTensorToCanvas.ts", "../src/dom/isMediaElement.ts", "../src/dom/NetInput.ts", "../src/dom/imageToSquare.ts", "../src/dom/toNetInput.ts", "../src/dom/extractFaces.ts", "../src/dom/extractFaceTensors.ts", "../src/dom/fetchOrThrow.ts", "../src/dom/fetchImage.ts", "../src/dom/fetchJson.ts", "../src/dom/fetchNetWeights.ts", "../src/dom/loadWeightMap.ts", "../src/common/getModelUris.ts", "../src/dom/matchDimensions.ts", "../src/faceFeatureExtractor/FaceFeatureExtractor.ts", "../src/NeuralNetwork.ts", "../src/faceFeatureExtractor/denseBlock.ts", "../src/common/depthwiseSeparableConv.ts", "../src/common/convLayer.ts", "../src/common/disposeUnusedWeightTensors.ts", "../src/common/extractConvParamsFactory.ts", "../src/common/extractFCParamsFactory.ts", "../src/common/extractSeparableConvParamsFactory.ts", "../src/common/types.ts", "../src/common/extractWeightEntryFactory.ts", "../src/common/extractWeightsFactory.ts", "../src/faceFeatureExtractor/extractorsFactory.ts", "../src/faceFeatureExtractor/extractParams.ts", "../src/common/loadConvParamsFactory.ts", "../src/faceFeatureExtractor/loadParamsFactory.ts", "../src/faceFeatureExtractor/extractParamsFromWeightMap.ts", "../src/faceProcessor/FaceProcessor.ts", "../src/common/fullyConnectedLayer.ts", "../src/faceProcessor/extractParams.ts", "../src/faceProcessor/extractParamsFromWeightMap.ts", "../src/faceProcessor/util.ts", "../src/faceExpressionNet/FaceExpressions.ts", "../src/factories/WithFaceExpressions.ts", "../src/draw/drawFaceExpressions.ts", "../src/factories/WithFaceLandmarks.ts", "../src/draw/DrawFaceLandmarks.ts", "../src/ageGenderNet/AgeGenderNet.ts", "../src/xception/TinyXception.ts", "../src/xception/extractParams.ts", "../src/xception/extractParamsFromWeightMap.ts", "../src/ageGenderNet/extractParams.ts", "../src/ageGenderNet/extractParamsFromWeightMap.ts", "../src/ageGenderNet/types.ts", "../src/faceLandmarkNet/FaceLandmark68NetBase.ts", "../src/faceLandmarkNet/FaceLandmark68Net.ts", "../src/faceFeatureExtractor/TinyFaceFeatureExtractor.ts", "../src/faceFeatureExtractor/extractParamsFromWeightMapTiny.ts", "../src/faceFeatureExtractor/extractParamsTiny.ts", "../src/faceLandmarkNet/FaceLandmark68TinyNet.ts", "../src/faceLandmarkNet/index.ts", "../src/faceRecognitionNet/FaceRecognitionNet.ts", "../src/faceRecognitionNet/convLayer.ts", "../src/faceRecognitionNet/scaleLayer.ts", "../src/faceRecognitionNet/extractParams.ts", "../src/faceRecognitionNet/extractParamsFromWeightMap.ts", "../src/faceRecognitionNet/residualLayer.ts", "../src/faceRecognitionNet/index.ts", "../src/factories/WithFaceDescriptor.ts", "../src/factories/WithAge.ts", "../src/factories/WithGender.ts", "../src/ssdMobilenetv1/SsdMobilenetv1.ts", "../src/ssdMobilenetv1/extractParams.ts", "../src/ssdMobilenetv1/extractParamsFromWeightMap.ts", "../src/ssdMobilenetv1/mobileNetV1.ts", "../src/ssdMobilenetv1/pointwiseConvLayer.ts", "../src/ssdMobilenetv1/nonMaxSuppression.ts", "../src/ssdMobilenetv1/outputLayer.ts", "../src/ssdMobilenetv1/predictionLayer.ts", "../src/ssdMobilenetv1/boxPredictionLayer.ts", "../src/ssdMobilenetv1/SsdMobilenetv1Options.ts", "../src/ssdMobilenetv1/index.ts", "../src/tinyYolov2/const.ts", "../src/tinyYolov2/TinyYolov2Base.ts", "../src/tinyYolov2/config.ts", "../src/tinyYolov2/convWithBatchNorm.ts", "../src/tinyYolov2/leaky.ts", "../src/tinyYolov2/depthwiseSeparableConv.ts", "../src/tinyYolov2/extractParams.ts", "../src/tinyYolov2/extractParamsFromWeightMap.ts", "../src/tinyYolov2/TinyYolov2Options.ts", "../src/tinyYolov2/TinyYolov2.ts", "../src/tinyYolov2/index.ts", "../src/tinyFaceDetector/TinyFaceDetectorOptions.ts", "../src/globalApi/ComposableTask.ts", "../src/globalApi/DetectFaceLandmarksTasks.ts", "../src/globalApi/extractFacesAndComputeResults.ts", "../src/tinyFaceDetector/const.ts", "../src/tinyFaceDetector/TinyFaceDetector.ts", "../src/globalApi/nets.ts", "../src/globalApi/PredictFaceExpressionsTask.ts", "../src/globalApi/PredictAgeAndGenderTask.ts", "../src/globalApi/ComputeFaceDescriptorsTasks.ts", "../src/globalApi/DetectFacesTasks.ts", "../src/globalApi/detectFaces.ts", "../src/globalApi/allFaces.ts", "../src/euclideanDistance.ts", "../src/globalApi/FaceMatcher.ts", "../src/tinyFaceDetector/index.ts", "../src/resizeResults.ts"],
  "sourcesContent": ["/* eslint-disable import/no-extraneous-dependencies */\r\n/* eslint-disable node/no-unpublished-import */\r\n\r\nexport * from '@tensorflow/tfjs-node-gpu';\r\n", "export function isNodejs(): boolean {\r\n  return typeof global === 'object'\r\n    && typeof require === 'function'\r\n    && typeof module !== 'undefined'\r\n    // issues with gatsby.js: module.exports is undefined\r\n    // && !!module.exports\r\n    && typeof process !== 'undefined' && !!process.version;\r\n}\r\n", "import * as tf from '../dist/tfjs.esm';\r\nimport * as draw from './draw/index';\r\nimport * as utils from './utils/index';\r\nimport * as pkg from '../package.json';\r\n\r\nexport { tf, draw, utils };\r\n\r\nexport * from './ageGenderNet/index';\r\nexport * from './classes/index';\r\nexport * from './dom/index';\r\nexport * from './env/index';\r\nexport * from './faceExpressionNet/index';\r\nexport * from './faceLandmarkNet/index';\r\nexport * from './faceRecognitionNet/index';\r\nexport * from './factories/index';\r\nexport * from './globalApi/index';\r\nexport * from './ops/index';\r\nexport * from './ssdMobilenetv1/index';\r\nexport * from './tinyFaceDetector/index';\r\nexport * from './tinyYolov2/index';\r\nexport * from './euclideanDistance';\r\nexport * from './NeuralNetwork';\r\nexport * from './resizeResults';\r\n\r\nconst node = (typeof process !== 'undefined');\r\nconst browser = (typeof navigator !== 'undefined') && (typeof navigator.userAgent !== 'undefined');\r\nexport const version = { faceapi: pkg.version as string, node, browser };\r\n", "export * from './drawContour';\r\nexport * from './drawDetections';\r\nexport * from './drawFaceExpressions';\r\nexport * from './DrawBox';\r\nexport * from './DrawFaceLandmarks';\r\nexport * from './DrawTextField';\r\n", "import { Point } from '../classes/index';\r\n\r\nexport function drawContour(\r\n  ctx: CanvasRenderingContext2D,\r\n  points: Point[],\r\n  isClosed: boolean = false,\r\n) {\r\n  ctx.beginPath();\r\n\r\n  points.slice(1).forEach(({ x, y }, prevIdx) => {\r\n    const from = points[prevIdx];\r\n    ctx.moveTo(from.x, from.y);\r\n    ctx.lineTo(x, y);\r\n  });\r\n\r\n  if (isClosed) {\r\n    const from = points[points.length - 1];\r\n    const to = points[0];\r\n    if (!from || !to) {\r\n      return;\r\n    }\r\n\r\n    ctx.moveTo(from.x, from.y);\r\n    ctx.lineTo(to.x, to.y);\r\n  }\r\n\r\n  ctx.stroke();\r\n}\r\n", "import * as tf from '../../dist/tfjs.esm';\r\n\r\nimport { Point } from '../classes/index';\r\nimport { Dimensions, IDimensions } from '../classes/Dimensions';\r\n\r\nexport function isTensor(tensor: any, dim: number) {\r\n  return tensor instanceof tf.Tensor && tensor.shape.length === dim;\r\n}\r\n\r\nexport function isTensor1D(tensor: any): tensor is tf.Tensor1D {\r\n  return isTensor(tensor, 1);\r\n}\r\n\r\nexport function isTensor2D(tensor: any): tensor is tf.Tensor2D {\r\n  return isTensor(tensor, 2);\r\n}\r\n\r\nexport function isTensor3D(tensor: any): tensor is tf.Tensor3D {\r\n  return isTensor(tensor, 3);\r\n}\r\n\r\nexport function isTensor4D(tensor: any): tensor is tf.Tensor4D {\r\n  return isTensor(tensor, 4);\r\n}\r\n\r\nexport function isFloat(num: number) {\r\n  return num % 1 !== 0;\r\n}\r\n\r\nexport function isEven(num: number) {\r\n  return num % 2 === 0;\r\n}\r\n\r\nexport function round(num: number, prec: number = 2) {\r\n  const f = 10 ** prec;\r\n  return Math.floor(num * f) / f;\r\n}\r\n\r\nexport function isDimensions(obj: any): boolean {\r\n  return obj && obj.width && obj.height;\r\n}\r\n\r\nexport function computeReshapedDimensions({ width, height }: IDimensions, inputSize: number) {\r\n  const scale = inputSize / Math.max(height, width);\r\n  return new Dimensions(Math.round(width * scale), Math.round(height * scale));\r\n}\r\n\r\nexport function getCenterPoint(pts: Point[]): Point {\r\n  return pts.reduce((sum, pt) => sum.add(pt), new Point(0, 0))\r\n    .div(new Point(pts.length, pts.length));\r\n}\r\n\r\nexport function range(num: number, start: number, step: number): number[] {\r\n  return Array(num).fill(0).map((_, i) => start + (i * step));\r\n}\r\n\r\nexport function isValidNumber(num: any) {\r\n  return !!num && (num !== Infinity) && (num !== -Infinity) && !Number.isNaN(num) || num === 0;\r\n}\r\n\r\nexport function isValidProbablitiy(num: any) {\r\n  return isValidNumber(num) && num >= 0 && num <= 1.0;\r\n}\r\n", "import { isValidNumber } from '../utils/index';\r\n\r\nexport interface IDimensions {\r\n  width: number\r\n  height: number\r\n}\r\n\r\nexport class Dimensions implements IDimensions {\r\n  private _width: number\r\n\r\n  private _height: number\r\n\r\n  constructor(width: number, height: number) {\r\n    if (!isValidNumber(width) || !isValidNumber(height)) {\r\n      throw new Error(`Dimensions.constructor - expected width and height to be valid numbers, instead have ${JSON.stringify({ width, height })}`);\r\n    }\r\n\r\n    this._width = width;\r\n    this._height = height;\r\n  }\r\n\r\n  public get width(): number { return this._width; }\r\n\r\n  public get height(): number { return this._height; }\r\n\r\n  public reverse(): Dimensions {\r\n    return new Dimensions(1 / this.width, 1 / this.height);\r\n  }\r\n}\r\n", "export interface IPoint {\r\n  x: number\r\n  y: number\r\n}\r\n\r\nexport class Point implements IPoint {\r\n  private _x: number\r\n\r\n  private _y: number\r\n\r\n  constructor(x: number, y: number) {\r\n    this._x = x;\r\n    this._y = y;\r\n  }\r\n\r\n  get x(): number { return this._x; }\r\n\r\n  get y(): number { return this._y; }\r\n\r\n  public add(pt: IPoint): Point {\r\n    return new Point(this.x + pt.x, this.y + pt.y);\r\n  }\r\n\r\n  public sub(pt: IPoint): Point {\r\n    return new Point(this.x - pt.x, this.y - pt.y);\r\n  }\r\n\r\n  public mul(pt: IPoint): Point {\r\n    return new Point(this.x * pt.x, this.y * pt.y);\r\n  }\r\n\r\n  public div(pt: IPoint): Point {\r\n    return new Point(this.x / pt.x, this.y / pt.y);\r\n  }\r\n\r\n  public abs(): Point {\r\n    return new Point(Math.abs(this.x), Math.abs(this.y));\r\n  }\r\n\r\n  public magnitude(): number {\r\n    return Math.sqrt((this.x ** 2) + (this.y ** 2));\r\n  }\r\n\r\n  public floor(): Point {\r\n    return new Point(Math.floor(this.x), Math.floor(this.y));\r\n  }\r\n}\r\n", "import { isDimensions, isValidNumber } from '../utils/index';\r\nimport { IBoundingBox } from './BoundingBox';\r\nimport { IDimensions } from './Dimensions';\r\nimport { Point } from './Point';\r\nimport { IRect } from './Rect';\r\n\r\nexport class Box<BoxType = any> implements IBoundingBox, IRect {\r\n  public static isRect(rect: any): boolean {\r\n    return !!rect && [rect.x, rect.y, rect.width, rect.height].every(isValidNumber);\r\n  }\r\n\r\n  public static assertIsValidBox(box: any, callee: string, allowNegativeDimensions: boolean = false) {\r\n    if (!Box.isRect(box)) {\r\n      throw new Error(`${callee} - invalid box: ${JSON.stringify(box)}, expected object with properties x, y, width, height`);\r\n    }\r\n\r\n    if (!allowNegativeDimensions && (box.width < 0 || box.height < 0)) {\r\n      throw new Error(`${callee} - width (${box.width}) and height (${box.height}) must be positive numbers`);\r\n    }\r\n  }\r\n\r\n  private _x: number\r\n\r\n  private _y: number\r\n\r\n  private _width: number\r\n\r\n  private _height: number\r\n\r\n  constructor(_box: IBoundingBox | IRect, allowNegativeDimensions: boolean = true) {\r\n    const box = (_box || {}) as any;\r\n\r\n    const isBbox = [box.left, box.top, box.right, box.bottom].every(isValidNumber);\r\n    const isRect = [box.x, box.y, box.width, box.height].every(isValidNumber);\r\n\r\n    if (!isRect && !isBbox) {\r\n      throw new Error(`Box.constructor - expected box to be IBoundingBox | IRect, instead have ${JSON.stringify(box)}`);\r\n    }\r\n\r\n    const [x, y, width, height] = isRect\r\n      ? [box.x, box.y, box.width, box.height]\r\n      : [box.left, box.top, box.right - box.left, box.bottom - box.top];\r\n\r\n    Box.assertIsValidBox({\r\n      x, y, width, height,\r\n    }, 'Box.constructor', allowNegativeDimensions);\r\n\r\n    this._x = x;\r\n    this._y = y;\r\n    this._width = width;\r\n    this._height = height;\r\n  }\r\n\r\n  public get x(): number { return this._x; }\r\n\r\n  public get y(): number { return this._y; }\r\n\r\n  public get width(): number { return this._width; }\r\n\r\n  public get height(): number { return this._height; }\r\n\r\n  public get left(): number { return this.x; }\r\n\r\n  public get top(): number { return this.y; }\r\n\r\n  public get right(): number { return this.x + this.width; }\r\n\r\n  public get bottom(): number { return this.y + this.height; }\r\n\r\n  public get area(): number { return this.width * this.height; }\r\n\r\n  public get topLeft(): Point { return new Point(this.left, this.top); }\r\n\r\n  public get topRight(): Point { return new Point(this.right, this.top); }\r\n\r\n  public get bottomLeft(): Point { return new Point(this.left, this.bottom); }\r\n\r\n  public get bottomRight(): Point { return new Point(this.right, this.bottom); }\r\n\r\n  public round(): Box<BoxType> {\r\n    const [x, y, width, height] = [this.x, this.y, this.width, this.height]\r\n      .map((val) => Math.round(val));\r\n    return new Box({\r\n      x, y, width, height,\r\n    });\r\n  }\r\n\r\n  public floor(): Box<BoxType> {\r\n    const [x, y, width, height] = [this.x, this.y, this.width, this.height]\r\n      .map((val) => Math.floor(val));\r\n    return new Box({\r\n      x, y, width, height,\r\n    });\r\n  }\r\n\r\n  public toSquare(): Box<BoxType> {\r\n    let {\r\n      x, y, width, height,\r\n    } = this;\r\n    const diff = Math.abs(width - height);\r\n    if (width < height) {\r\n      x -= (diff / 2);\r\n      width += diff;\r\n    }\r\n    if (height < width) {\r\n      y -= (diff / 2);\r\n      height += diff;\r\n    }\r\n\r\n    return new Box({\r\n      x, y, width, height,\r\n    });\r\n  }\r\n\r\n  public rescale(s: IDimensions | number): Box<BoxType> {\r\n    const scaleX = isDimensions(s) ? (s as IDimensions).width : s as number;\r\n    const scaleY = isDimensions(s) ? (s as IDimensions).height : s as number;\r\n    return new Box({\r\n      x: this.x * scaleX,\r\n      y: this.y * scaleY,\r\n      width: this.width * scaleX,\r\n      height: this.height * scaleY,\r\n    });\r\n  }\r\n\r\n  public pad(padX: number, padY: number): Box<BoxType> {\r\n    const [x, y, width, height] = [\r\n      this.x - (padX / 2),\r\n      this.y - (padY / 2),\r\n      this.width + padX,\r\n      this.height + padY,\r\n    ];\r\n    return new Box({\r\n      x, y, width, height,\r\n    });\r\n  }\r\n\r\n  public clipAtImageBorders(imgWidth: number, imgHeight: number): Box<BoxType> {\r\n    const {\r\n      x, y, right, bottom,\r\n    } = this;\r\n    const clippedX = Math.max(x, 0);\r\n    const clippedY = Math.max(y, 0);\r\n\r\n    const newWidth = right - clippedX;\r\n    const newHeight = bottom - clippedY;\r\n    const clippedWidth = Math.min(newWidth, imgWidth - clippedX);\r\n    const clippedHeight = Math.min(newHeight, imgHeight - clippedY);\r\n\r\n    return (new Box({\r\n      x: clippedX, y: clippedY, width: clippedWidth, height: clippedHeight,\r\n    })).floor();\r\n  }\r\n\r\n  public shift(sx: number, sy: number): Box<BoxType> {\r\n    const { width, height } = this;\r\n    const x = this.x + sx;\r\n    const y = this.y + sy;\r\n\r\n    return new Box({\r\n      x, y, width, height,\r\n    });\r\n  }\r\n\r\n  public padAtBorders(imageHeight: number, imageWidth: number) {\r\n    const w = this.width + 1;\r\n    const h = this.height + 1;\r\n\r\n    const dx = 1;\r\n    const dy = 1;\r\n    let edx = w;\r\n    let edy = h;\r\n\r\n    let x = this.left;\r\n    let y = this.top;\r\n    let ex = this.right;\r\n    let ey = this.bottom;\r\n\r\n    if (ex > imageWidth) {\r\n      edx = -ex + imageWidth + w;\r\n      ex = imageWidth;\r\n    }\r\n    if (ey > imageHeight) {\r\n      edy = -ey + imageHeight + h;\r\n      ey = imageHeight;\r\n    }\r\n    if (x < 1) {\r\n      edy = 2 - x;\r\n      x = 1;\r\n    }\r\n    if (y < 1) {\r\n      edy = 2 - y;\r\n      y = 1;\r\n    }\r\n\r\n    return {\r\n      dy, edy, dx, edx, y, ey, x, ex, w, h,\r\n    };\r\n  }\r\n\r\n  public calibrate(region: Box) {\r\n    return new Box({\r\n      left: this.left + (region.left * this.width),\r\n      top: this.top + (region.top * this.height),\r\n      right: this.right + (region.right * this.width),\r\n      bottom: this.bottom + (region.bottom * this.height),\r\n    }).toSquare().round();\r\n  }\r\n}\r\n", "import { Box } from './Box';\r\n\r\nexport interface IBoundingBox {\r\n  left: number\r\n  top: number\r\n  right: number\r\n  bottom: number\r\n}\r\n\r\nexport class BoundingBox extends Box<BoundingBox> implements IBoundingBox {\r\n  constructor(left: number, top: number, right: number, bottom: number, allowNegativeDimensions: boolean = false) {\r\n    super({\r\n      left, top, right, bottom,\r\n    }, allowNegativeDimensions);\r\n  }\r\n}\r\n", "import { Box } from './Box';\r\nimport { Dimensions, IDimensions } from './Dimensions';\r\nimport { IRect, Rect } from './Rect';\r\n\r\nexport class ObjectDetection {\r\n  private _score: number\r\n\r\n  private _classScore: number\r\n\r\n  private _className: string\r\n\r\n  private _box: Rect\r\n\r\n  private _imageDims: Dimensions\r\n\r\n  constructor(\r\n    score: number,\r\n    classScore: number,\r\n    className: string,\r\n    relativeBox: IRect,\r\n    imageDims: IDimensions,\r\n  ) {\r\n    this._imageDims = new Dimensions(imageDims.width, imageDims.height);\r\n    this._score = score;\r\n    this._classScore = classScore;\r\n    this._className = className;\r\n    this._box = new Box(relativeBox).rescale(this._imageDims);\r\n  }\r\n\r\n  public get score(): number { return this._score; }\r\n\r\n  public get classScore(): number { return this._classScore; }\r\n\r\n  public get className(): string { return this._className; }\r\n\r\n  public get box(): Box { return this._box; }\r\n\r\n  public get imageDims(): Dimensions { return this._imageDims; }\r\n\r\n  public get imageWidth(): number { return this.imageDims.width; }\r\n\r\n  public get imageHeight(): number { return this.imageDims.height; }\r\n\r\n  public get relativeBox(): Box { return new Box(this._box).rescale(this.imageDims.reverse()); }\r\n\r\n  public forSize(width: number, height: number): ObjectDetection {\r\n    return new ObjectDetection(\r\n      this.score,\r\n      this.classScore,\r\n      this.className,\r\n      this.relativeBox,\r\n      { width, height },\r\n    );\r\n  }\r\n}\r\n", "import { Box } from './Box';\r\nimport { IDimensions } from './Dimensions';\r\nimport { ObjectDetection } from './ObjectDetection';\r\nimport { Rect } from './Rect';\r\n\r\nexport interface IFaceDetecion {\r\n  score: number\r\n  box: Box\r\n}\r\n\r\nexport class FaceDetection extends ObjectDetection implements IFaceDetecion {\r\n  constructor(\r\n    score: number,\r\n    relativeBox: Rect,\r\n    imageDims: IDimensions,\r\n  ) {\r\n    super(score, score, '', relativeBox, imageDims);\r\n  }\r\n\r\n  public forSize(width: number, height: number): FaceDetection {\r\n    const { score, relativeBox, imageDims } = super.forSize(width, height);\r\n    return new FaceDetection(score, relativeBox, imageDims);\r\n  }\r\n}\r\n", "import { Box } from '../classes/Box';\r\n\r\nexport function iou(box1: Box, box2: Box, isIOU: boolean = true) {\r\n  const width = Math.max(0.0, Math.min(box1.right, box2.right) - Math.max(box1.left, box2.left));\r\n  const height = Math.max(0.0, Math.min(box1.bottom, box2.bottom) - Math.max(box1.top, box2.top));\r\n  const interSection = width * height;\r\n\r\n  return isIOU\r\n    ? interSection / (box1.area + box2.area - interSection)\r\n    : interSection / Math.min(box1.area, box2.area);\r\n}\r\n", "import { BoundingBox, IPoint } from '../classes/index';\r\n\r\nexport function minBbox(pts: IPoint[]): BoundingBox {\r\n  const xs = pts.map((pt) => pt.x);\r\n  const ys = pts.map((pt) => pt.y);\r\n  const minX = xs.reduce((min, x) => (x < min ? x : min), Infinity);\r\n  const minY = ys.reduce((min, y) => (y < min ? y : min), Infinity);\r\n  const maxX = xs.reduce((max, x) => (max < x ? x : max), 0);\r\n  const maxY = ys.reduce((max, y) => (max < y ? y : max), 0);\r\n\r\n  return new BoundingBox(minX, minY, maxX, maxY);\r\n}\r\n", "import { Box } from '../classes/Box';\r\nimport { iou } from './iou';\r\n\r\nexport function nonMaxSuppression(\r\n  boxes: Box[],\r\n  scores: number[],\r\n  iouThreshold: number,\r\n  isIOU: boolean = true,\r\n): number[] {\r\n  let indicesSortedByScore = scores\r\n    .map((score, boxIndex) => ({ score, boxIndex }))\r\n    .sort((c1, c2) => c1.score - c2.score)\r\n    .map((c) => c.boxIndex);\r\n\r\n  const pick: number[] = [];\r\n\r\n  while (indicesSortedByScore.length > 0) {\r\n    const curr = indicesSortedByScore.pop() as number;\r\n    pick.push(curr);\r\n\r\n    const indices = indicesSortedByScore;\r\n\r\n    const outputs: number[] = [];\r\n    for (let i = 0; i < indices.length; i++) {\r\n      const idx = indices[i];\r\n\r\n      const currBox = boxes[curr];\r\n      const idxBox = boxes[idx];\r\n\r\n      outputs.push(iou(currBox, idxBox, isIOU));\r\n    }\r\n\r\n    indicesSortedByScore = indicesSortedByScore.filter(\r\n      (_, j) => outputs[j] <= iouThreshold,\r\n    );\r\n  }\r\n\r\n  return pick;\r\n}\r\n", "import * as tf from '../../dist/tfjs.esm';\r\n\r\nexport function normalize(x: tf.Tensor4D, meanRgb: number[]): tf.Tensor4D {\r\n  return tf.tidy(() => {\r\n    const [r, g, b] = meanRgb;\r\n    const avg_r = tf.fill([...x.shape.slice(0, 3), 1], r, 'float32');\r\n    const avg_g = tf.fill([...x.shape.slice(0, 3), 1], g, 'float32');\r\n    const avg_b = tf.fill([...x.shape.slice(0, 3), 1], b, 'float32');\r\n    const avg_rgb = tf.concat([avg_r, avg_g, avg_b], 3);\r\n\r\n    return tf.sub(x, avg_rgb);\r\n  });\r\n}\r\n", "import * as tf from '../../dist/tfjs.esm';\r\n\r\n/**\r\n * Pads the smaller dimension of an image tensor with zeros, such that width === height.\r\n *\r\n * @param imgTensor The image tensor.\r\n * @param isCenterImage (optional, default: false) If true, add an equal amount of padding on\r\n * both sides of the minor dimension oof the image.\r\n * @returns The padded tensor with width === height.\r\n */\r\nexport function padToSquare(\r\n  imgTensor: tf.Tensor4D,\r\n  isCenterImage: boolean = false,\r\n): tf.Tensor4D {\r\n  return tf.tidy(() => {\r\n    const [height, width] = imgTensor.shape.slice(1);\r\n    if (height === width) {\r\n      return imgTensor;\r\n    }\r\n\r\n    const dimDiff = Math.abs(height - width);\r\n    const paddingAmount = Math.round(dimDiff * (isCenterImage ? 0.5 : 1));\r\n    const paddingAxis = height > width ? 2 : 1;\r\n\r\n    const createPaddingTensor = (paddingAmountLocal: number): tf.Tensor => {\r\n      const paddingTensorShape = imgTensor.shape.slice();\r\n      paddingTensorShape[paddingAxis] = paddingAmountLocal;\r\n      return tf.fill(paddingTensorShape, 0, 'float32');\r\n    };\r\n\r\n    const paddingTensorAppend = createPaddingTensor(paddingAmount);\r\n    const remainingPaddingAmount = dimDiff - (paddingTensorAppend.shape[paddingAxis] as number);\r\n\r\n    const paddingTensorPrepend = isCenterImage && remainingPaddingAmount\r\n      ? createPaddingTensor(remainingPaddingAmount)\r\n      : null;\r\n\r\n    const tensorsToStack = [\r\n      paddingTensorPrepend,\r\n      imgTensor,\r\n      paddingTensorAppend,\r\n    ]\r\n      .filter((t) => !!t)\r\n      // .map((t: tf.Tensor) => t.toFloat()) as tf.Tensor4D[]\r\n      .map((t: tf.Tensor) => tf.cast(t, 'float32')) as tf.Tensor4D[];\r\n    return tf.concat(tensorsToStack, paddingAxis);\r\n  });\r\n}\r\n", "export function shuffleArray(inputArray: any[]) {\r\n  const array = inputArray.slice();\r\n  for (let i = array.length - 1; i > 0; i--) {\r\n    const j = Math.floor(Math.random() * (i + 1));\r\n    const x = array[i];\r\n    array[i] = array[j];\r\n    array[j] = x;\r\n  }\r\n  return array;\r\n}\r\n", "export * from './iou';\r\nexport * from './minBbox';\r\nexport * from './nonMaxSuppression';\r\nexport * from './normalize';\r\nexport * from './padToSquare';\r\nexport * from './shuffleArray';\r\n\r\nexport function sigmoid(x: number) {\r\n  return 1 / (1 + Math.exp(-x));\r\n}\r\n\r\nexport function inverseSigmoid(x: number) {\r\n  return Math.log(x / (1 - x));\r\n}\r\n", "import { Box } from './Box';\r\n\r\nexport interface IRect {\r\n  x: number\r\n  y: number\r\n  width: number\r\n  height: number\r\n}\r\n\r\nexport class Rect extends Box<Rect> implements IRect {\r\n  constructor(x: number, y: number, width: number, height: number, allowNegativeDimensions: boolean = false) {\r\n    super({\r\n      x, y, width, height,\r\n    }, allowNegativeDimensions);\r\n  }\r\n}\r\n", "import { minBbox } from '../ops/index';\r\nimport { getCenterPoint } from '../utils/index';\r\nimport { IBoundingBox } from './BoundingBox';\r\nimport { Box } from './Box';\r\nimport { Dimensions, IDimensions } from './Dimensions';\r\nimport { FaceDetection } from './FaceDetection';\r\nimport { Point } from './Point';\r\nimport { IRect, Rect } from './Rect';\r\n\r\n// face alignment constants\r\nconst relX = 0.5;\r\nconst relY = 0.43;\r\nconst relScale = 0.45;\r\n\r\nexport interface IFaceLandmarks {\r\n  positions: Point[]\r\n  shift: Point\r\n}\r\n\r\nexport class FaceLandmarks implements IFaceLandmarks {\r\n  protected _shift: Point\r\n\r\n  protected _positions: Point[]\r\n\r\n  protected _imgDims: Dimensions\r\n\r\n  constructor(\r\n    relativeFaceLandmarkPositions: Point[],\r\n    imgDims: IDimensions,\r\n    shift: Point = new Point(0, 0),\r\n  ) {\r\n    const { width, height } = imgDims;\r\n    this._imgDims = new Dimensions(width, height);\r\n    this._shift = shift;\r\n    this._positions = relativeFaceLandmarkPositions.map(\r\n      (pt) => pt.mul(new Point(width, height)).add(shift),\r\n    );\r\n  }\r\n\r\n  public get shift(): Point { return new Point(this._shift.x, this._shift.y); }\r\n\r\n  public get imageWidth(): number { return this._imgDims.width; }\r\n\r\n  public get imageHeight(): number { return this._imgDims.height; }\r\n\r\n  public get positions(): Point[] { return this._positions; }\r\n\r\n  public get relativePositions(): Point[] {\r\n    return this._positions.map(\r\n      (pt) => pt.sub(this._shift).div(new Point(this.imageWidth, this.imageHeight)),\r\n    );\r\n  }\r\n\r\n  public forSize<T extends FaceLandmarks>(width: number, height: number): T {\r\n    return new (this.constructor as any)(\r\n      this.relativePositions,\r\n      { width, height },\r\n    );\r\n  }\r\n\r\n  public shiftBy<T extends FaceLandmarks>(x: number, y: number): T {\r\n    return new (this.constructor as any)(\r\n      this.relativePositions,\r\n      this._imgDims,\r\n      new Point(x, y),\r\n    );\r\n  }\r\n\r\n  public shiftByPoint<T extends FaceLandmarks>(pt: Point): T {\r\n    return this.shiftBy(pt.x, pt.y);\r\n  }\r\n\r\n  /**\r\n   * Aligns the face landmarks after face detection from the relative positions of the faces\r\n   * bounding box, or it's current shift. This function should be used to align the face images\r\n   * after face detection has been performed, before they are passed to the face recognition net.\r\n   * This will make the computed face descriptor more accurate.\r\n   *\r\n   * @param detection (optional) The bounding box of the face or the face detection result. If\r\n   * no argument was passed the position of the face landmarks are assumed to be relative to\r\n   * it's current shift.\r\n   * @returns The bounding box of the aligned face.\r\n   */\r\n  public align(\r\n    detection?: FaceDetection | IRect | IBoundingBox | null,\r\n    options: { useDlibAlignment?: boolean, minBoxPadding?: number } = { },\r\n  ): Box {\r\n    if (detection) {\r\n      const box = detection instanceof FaceDetection\r\n        ? detection.box.floor()\r\n        : new Box(detection);\r\n\r\n      return this.shiftBy(box.x, box.y).align(null, options);\r\n    }\r\n\r\n    const { useDlibAlignment, minBoxPadding } = { useDlibAlignment: false, minBoxPadding: 0.2, ...options };\r\n\r\n    if (useDlibAlignment) {\r\n      return this.alignDlib();\r\n    }\r\n\r\n    return this.alignMinBbox(minBoxPadding);\r\n  }\r\n\r\n  private alignDlib(): Box {\r\n    const centers = this.getRefPointsForAlignment();\r\n\r\n    const [leftEyeCenter, rightEyeCenter, mouthCenter] = centers;\r\n    const distToMouth = (pt: Point) => mouthCenter.sub(pt).magnitude();\r\n    const eyeToMouthDist = (distToMouth(leftEyeCenter) + distToMouth(rightEyeCenter)) / 2;\r\n\r\n    const size = Math.floor(eyeToMouthDist / relScale);\r\n\r\n    const refPoint = getCenterPoint(centers);\r\n    // TODO: pad in case rectangle is out of image bounds\r\n    const x = Math.floor(Math.max(0, refPoint.x - (relX * size)));\r\n    const y = Math.floor(Math.max(0, refPoint.y - (relY * size)));\r\n\r\n    return new Rect(x, y, Math.min(size, this.imageWidth + x), Math.min(size, this.imageHeight + y));\r\n  }\r\n\r\n  private alignMinBbox(padding: number): Box {\r\n    const box = minBbox(this.positions);\r\n    return box.pad(box.width * padding, box.height * padding);\r\n  }\r\n\r\n  protected getRefPointsForAlignment(): Point[] {\r\n    throw new Error('getRefPointsForAlignment not implemented by base class');\r\n  }\r\n}\r\n", "import { getCenterPoint } from '../utils/index';\r\nimport { FaceLandmarks } from './FaceLandmarks';\r\nimport { Point } from './Point';\r\n\r\nexport class FaceLandmarks5 extends FaceLandmarks {\r\n  protected getRefPointsForAlignment(): Point[] {\r\n    const pts = this.positions;\r\n    return [\r\n      pts[0],\r\n      pts[1],\r\n      getCenterPoint([pts[3], pts[4]]),\r\n    ];\r\n  }\r\n}\r\n", "import { getCenterPoint } from '../utils/index';\r\nimport { FaceLandmarks } from './FaceLandmarks';\r\nimport { Point } from './Point';\r\n\r\nexport class FaceLandmarks68 extends FaceLandmarks {\r\n  public getJawOutline(): Point[] {\r\n    return this.positions.slice(0, 17);\r\n  }\r\n\r\n  public getLeftEyeBrow(): Point[] {\r\n    return this.positions.slice(17, 22);\r\n  }\r\n\r\n  public getRightEyeBrow(): Point[] {\r\n    return this.positions.slice(22, 27);\r\n  }\r\n\r\n  public getNose(): Point[] {\r\n    return this.positions.slice(27, 36);\r\n  }\r\n\r\n  public getLeftEye(): Point[] {\r\n    return this.positions.slice(36, 42);\r\n  }\r\n\r\n  public getRightEye(): Point[] {\r\n    return this.positions.slice(42, 48);\r\n  }\r\n\r\n  public getMouth(): Point[] {\r\n    return this.positions.slice(48, 68);\r\n  }\r\n\r\n  protected getRefPointsForAlignment(): Point[] {\r\n    return [\r\n      this.getLeftEye(),\r\n      this.getRightEye(),\r\n      this.getMouth(),\r\n    ].map(getCenterPoint);\r\n  }\r\n}\r\n", "import { round } from '../utils/index';\r\n\r\nexport interface IFaceMatch {\r\n  label: string\r\n  distance: number\r\n}\r\n\r\nexport class FaceMatch implements IFaceMatch {\r\n  private _label: string\r\n\r\n  private _distance: number\r\n\r\n  constructor(label: string, distance: number) {\r\n    this._label = label;\r\n    this._distance = distance;\r\n  }\r\n\r\n  public get label(): string { return this._label; }\r\n\r\n  public get distance(): number { return this._distance; }\r\n\r\n  public toString(withDistance: boolean = true): string {\r\n    return `${this.label}${withDistance ? ` (${round(this.distance)})` : ''}`;\r\n  }\r\n}\r\n", "import { isValidNumber } from '../utils/index';\r\nimport { IBoundingBox } from './BoundingBox';\r\nimport { Box } from './Box';\r\nimport { IRect } from './Rect';\r\n\r\nexport class LabeledBox extends Box<LabeledBox> {\r\n  public static assertIsValidLabeledBox(box: any, callee: string) {\r\n    Box.assertIsValidBox(box, callee);\r\n\r\n    if (!isValidNumber(box.label)) {\r\n      throw new Error(`${callee} - expected property label (${box.label}) to be a number`);\r\n    }\r\n  }\r\n\r\n  private _label: number\r\n\r\n  constructor(box: IBoundingBox | IRect | any, label: number) {\r\n    super(box);\r\n    this._label = label;\r\n  }\r\n\r\n  public get label(): number { return this._label; }\r\n}\r\n", "export class LabeledFaceDescriptors {\r\n  private _label: string\r\n\r\n  private _descriptors: Float32Array[]\r\n\r\n  constructor(label: string, descriptors: Float32Array[]) {\r\n    if (!(typeof label === 'string')) {\r\n      throw new Error('LabeledFaceDescriptors - constructor expected label to be a string');\r\n    }\r\n\r\n    if (!Array.isArray(descriptors) || descriptors.some((desc) => !(desc instanceof Float32Array))) {\r\n      throw new Error('LabeledFaceDescriptors - constructor expected descriptors to be an array of Float32Array');\r\n    }\r\n\r\n    this._label = label;\r\n    this._descriptors = descriptors;\r\n  }\r\n\r\n  public get label(): string { return this._label; }\r\n\r\n  public get descriptors(): Float32Array[] { return this._descriptors; }\r\n\r\n  public toJSON(): any {\r\n    return {\r\n      label: this.label,\r\n      descriptors: this.descriptors.map((d) => Array.from(d)),\r\n    };\r\n  }\r\n\r\n  public static fromJSON(json: any): LabeledFaceDescriptors {\r\n    const descriptors = json.descriptors.map((d: any) => new Float32Array(d));\r\n    return new LabeledFaceDescriptors(json.label, descriptors);\r\n  }\r\n}\r\n", "import { isValidProbablitiy } from '../utils/index';\r\nimport { IBoundingBox } from './BoundingBox';\r\nimport { LabeledBox } from './LabeledBox';\r\nimport { IRect } from './Rect';\r\n\r\nexport class PredictedBox extends LabeledBox {\r\n  public static assertIsValidPredictedBox(box: any, callee: string) {\r\n    LabeledBox.assertIsValidLabeledBox(box, callee);\r\n\r\n    if (\r\n      !isValidProbablitiy(box.score)\r\n      || !isValidProbablitiy(box.classScore)\r\n    ) {\r\n      throw new Error(`${callee} - expected properties score (${box.score}) and (${box.classScore}) to be a number between [0, 1]`);\r\n    }\r\n  }\r\n\r\n  private _score: number\r\n\r\n  private _classScore: number\r\n\r\n  constructor(box: IBoundingBox | IRect | any, label: number, score: number, classScore: number) {\r\n    super(box, label);\r\n    this._score = score;\r\n    this._classScore = classScore;\r\n  }\r\n\r\n  public get score(): number { return this._score; }\r\n\r\n  public get classScore(): number { return this._classScore; }\r\n}\r\n", "import { FaceDetection } from '../classes/FaceDetection';\r\n\r\nexport type WithFaceDetection<TSource> = TSource & {\r\n  detection: FaceDetection\r\n}\r\n\r\nexport function isWithFaceDetection(obj: any): obj is WithFaceDetection<{}> {\r\n  return obj.detection instanceof FaceDetection;\r\n}\r\n\r\nexport function extendWithFaceDetection<\r\n  TSource\r\n>(\r\n  sourceObj: TSource,\r\n  detection: FaceDetection,\r\n): WithFaceDetection<TSource> {\r\n  const extension = { detection };\r\n  return { ...sourceObj, ...extension };\r\n}\r\n", "import { Environment } from './types';\r\n\r\nexport function createBrowserEnv(): Environment {\r\n  const fetch = window.fetch;\r\n  if (!fetch) throw new Error('fetch - missing fetch implementation for browser environment');\r\n\r\n  const readFile = () => {\r\n    throw new Error('readFile - filesystem not available for browser environment');\r\n  };\r\n\r\n  return {\r\n    Canvas: HTMLCanvasElement,\r\n    CanvasRenderingContext2D,\r\n    Image: HTMLImageElement,\r\n    ImageData,\r\n    Video: HTMLVideoElement,\r\n    createCanvasElement: () => document.createElement('canvas'),\r\n    createImageElement: () => document.createElement('img'),\r\n    fetch,\r\n    readFile,\r\n  };\r\n}\r\n", "import { FileSystem } from './types';\r\n\r\nexport function createFileSystem(fs?: any): FileSystem {\r\n  let requireFsError = '';\r\n\r\n  if (!fs) {\r\n    try {\r\n      // eslint-disable-next-line global-require\r\n      fs = require('fs');\r\n    } catch (err) {\r\n      requireFsError = err.toString();\r\n    }\r\n  }\r\n\r\n  const readFile = fs\r\n    ? (filePath: string) => new Promise<Buffer>((resolve, reject) => {\r\n      fs.readFile(filePath, (err: any, buffer: Buffer) => (err ? reject(err) : resolve(buffer)));\r\n    })\r\n    : () => {\r\n      throw new Error(`readFile - failed to require fs in nodejs environment with error: ${requireFsError}`);\r\n    };\r\n\r\n  return {\r\n    readFile,\r\n  };\r\n}\r\n", "/* eslint-disable max-classes-per-file */\r\nimport { createFileSystem } from './createFileSystem';\r\nimport { Environment } from './types';\r\n\r\nexport function createNodejsEnv(): Environment {\r\n  // eslint-disable-next-line dot-notation\r\n  const Canvas = global['Canvas'] || global.HTMLCanvasElement;\r\n  const Image = global.Image || global.HTMLImageElement;\r\n\r\n  const createCanvasElement = () => {\r\n    if (Canvas) return new Canvas();\r\n    throw new Error('createCanvasElement - missing Canvas implementation for nodejs environment');\r\n  };\r\n\r\n  const createImageElement = () => {\r\n    if (Image) return new Image();\r\n    throw new Error('createImageElement - missing Image implementation for nodejs environment');\r\n  };\r\n\r\n  const fetch = global.fetch;\r\n  // if (!fetch) throw new Error('fetch - missing fetch implementation for nodejs environment');\r\n\r\n  const fileSystem = createFileSystem();\r\n\r\n  return {\r\n    Canvas: Canvas || class {},\r\n    CanvasRenderingContext2D: global.CanvasRenderingContext2D || class {},\r\n    Image: Image || class {},\r\n    ImageData: global.ImageData || class {},\r\n    Video: global.HTMLVideoElement || class {},\r\n    createCanvasElement,\r\n    createImageElement,\r\n    fetch,\r\n    ...fileSystem,\r\n  };\r\n}\r\n", "export function isBrowser(): boolean {\r\n  return typeof window === 'object'\r\n    && typeof document !== 'undefined'\r\n    && typeof HTMLImageElement !== 'undefined'\r\n    && typeof HTMLCanvasElement !== 'undefined'\r\n    && typeof HTMLVideoElement !== 'undefined'\r\n    && typeof ImageData !== 'undefined'\r\n    && typeof CanvasRenderingContext2D !== 'undefined';\r\n}\r\n", "import { createBrowserEnv } from './createBrowserEnv';\r\nimport { createFileSystem } from './createFileSystem';\r\nimport { createNodejsEnv } from './createNodejsEnv';\r\nimport { isBrowser } from './isBrowser';\r\nimport { isNodejs } from './isNodejs';\r\nimport { Environment } from './types';\r\n\r\nlet environment: Environment | null;\r\n\r\nfunction getEnv(): Environment {\r\n  if (!environment) {\r\n    throw new Error('getEnv - environment is not defined, check isNodejs() and isBrowser()');\r\n  }\r\n  return environment;\r\n}\r\n\r\nfunction setEnv(env: Environment) {\r\n  environment = env;\r\n}\r\n\r\nfunction initialize() {\r\n  // check for isBrowser() first to prevent electron renderer process\r\n  // to be initialized with wrong environment due to isNodejs() returning true\r\n  if (isBrowser()) return setEnv(createBrowserEnv());\r\n  if (isNodejs()) return setEnv(createNodejsEnv());\r\n  return null;\r\n}\r\n\r\nfunction monkeyPatch(env: Partial<Environment>) {\r\n  if (!environment) {\r\n    initialize();\r\n  }\r\n\r\n  if (!environment) {\r\n    throw new Error('monkeyPatch - environment is not defined, check isNodejs() and isBrowser()');\r\n  }\r\n\r\n  const { Canvas = environment.Canvas, Image = environment.Image } = env;\r\n  environment.Canvas = Canvas;\r\n  environment.Image = Image;\r\n  environment.createCanvasElement = env.createCanvasElement || (() => new Canvas());\r\n  environment.createImageElement = env.createImageElement || (() => new Image());\r\n\r\n  environment.ImageData = env.ImageData || environment.ImageData;\r\n  environment.Video = env.Video || environment.Video;\r\n  environment.fetch = env.fetch || environment.fetch;\r\n  environment.readFile = env.readFile || environment.readFile;\r\n}\r\n\r\nexport const env = {\r\n  getEnv,\r\n  setEnv,\r\n  initialize,\r\n  createBrowserEnv,\r\n  createFileSystem,\r\n  createNodejsEnv,\r\n  monkeyPatch,\r\n  isBrowser,\r\n  isNodejs,\r\n};\r\n\r\ninitialize();\r\n\r\nexport * from './types';\r\n", "import { env } from '../env/index';\r\n\r\nexport function resolveInput(arg: string | any) {\r\n  if (!env.isNodejs() && typeof arg === 'string') {\r\n    return document.getElementById(arg);\r\n  }\r\n  return arg;\r\n}\r\n", "import { env } from '../env/index';\r\nimport { resolveInput } from './resolveInput';\r\n\r\nexport function getContext2dOrThrow(canvasArg: string | HTMLCanvasElement | CanvasRenderingContext2D): CanvasRenderingContext2D {\r\n  const { Canvas, CanvasRenderingContext2D } = env.getEnv();\r\n\r\n  if (canvasArg instanceof CanvasRenderingContext2D) {\r\n    return canvasArg;\r\n  }\r\n\r\n  const canvas = resolveInput(canvasArg);\r\n\r\n  if (!(canvas instanceof Canvas)) {\r\n    throw new Error('resolveContext2d - expected canvas to be of instance of Canvas');\r\n  }\r\n\r\n  const ctx = canvas.getContext('2d');\r\n  if (!ctx) {\r\n    throw new Error('resolveContext2d - canvas 2d context is null');\r\n  }\r\n\r\n  return ctx;\r\n}\r\n", "/* eslint-disable max-classes-per-file */\r\nimport { IDimensions, IPoint } from '../classes/index';\r\nimport { getContext2dOrThrow } from '../dom/getContext2dOrThrow';\r\nimport { resolveInput } from '../dom/resolveInput';\r\n\r\n// eslint-disable-next-line no-shadow\r\nexport enum AnchorPosition {\r\n  // eslint-disable-next-line no-unused-vars\r\n  TOP_LEFT = 'TOP_LEFT',\r\n  // eslint-disable-next-line no-unused-vars\r\n  TOP_RIGHT = 'TOP_RIGHT',\r\n  // eslint-disable-next-line no-unused-vars\r\n  BOTTOM_LEFT = 'BOTTOM_LEFT',\r\n  // eslint-disable-next-line no-unused-vars\r\n  BOTTOM_RIGHT = 'BOTTOM_RIGHT'\r\n}\r\n\r\nexport interface IDrawTextFieldOptions {\r\n  anchorPosition?: AnchorPosition\r\n  backgroundColor?: string\r\n  fontColor?: string\r\n  fontSize?: number\r\n  fontStyle?: string\r\n  padding?: number\r\n}\r\n\r\nexport class DrawTextFieldOptions implements IDrawTextFieldOptions {\r\n  public anchorPosition: AnchorPosition\r\n\r\n  public backgroundColor: string\r\n\r\n  public fontColor: string\r\n\r\n  public fontSize: number\r\n\r\n  public fontStyle: string\r\n\r\n  public padding: number\r\n\r\n  constructor(options: IDrawTextFieldOptions = {}) {\r\n    const {\r\n      anchorPosition, backgroundColor, fontColor, fontSize, fontStyle, padding,\r\n    } = options;\r\n    this.anchorPosition = anchorPosition || AnchorPosition.TOP_LEFT;\r\n    this.backgroundColor = backgroundColor || 'rgba(0, 0, 0, 0.5)';\r\n    this.fontColor = fontColor || 'rgba(255, 255, 255, 1)';\r\n    this.fontSize = fontSize || 14;\r\n    this.fontStyle = fontStyle || 'Georgia';\r\n    this.padding = padding || 4;\r\n  }\r\n}\r\n\r\nexport class DrawTextField {\r\n  public text: string[]\r\n\r\n  public anchor : IPoint\r\n\r\n  public options: DrawTextFieldOptions\r\n\r\n  constructor(\r\n    text: string | string[] | DrawTextField,\r\n    anchor: IPoint,\r\n    options: IDrawTextFieldOptions = {},\r\n  ) {\r\n    // eslint-disable-next-line no-nested-ternary\r\n    this.text = typeof text === 'string'\r\n      ? [text]\r\n      : (text instanceof DrawTextField ? text.text : text);\r\n    this.anchor = anchor;\r\n    this.options = new DrawTextFieldOptions(options);\r\n  }\r\n\r\n  measureWidth(ctx: CanvasRenderingContext2D): number {\r\n    const { padding } = this.options;\r\n    return this.text.map((l) => ctx.measureText(l).width).reduce((w0, w1) => (w0 < w1 ? w1 : w0), 0) + (2 * padding);\r\n  }\r\n\r\n  measureHeight(): number {\r\n    const { fontSize, padding } = this.options;\r\n    return this.text.length * fontSize + (2 * padding);\r\n  }\r\n\r\n  getUpperLeft(ctx: CanvasRenderingContext2D, canvasDims?: IDimensions): IPoint {\r\n    const { anchorPosition } = this.options;\r\n    const isShiftLeft = anchorPosition === AnchorPosition.BOTTOM_RIGHT || anchorPosition === AnchorPosition.TOP_RIGHT;\r\n    const isShiftTop = anchorPosition === AnchorPosition.BOTTOM_LEFT || anchorPosition === AnchorPosition.BOTTOM_RIGHT;\r\n\r\n    const textFieldWidth = this.measureWidth(ctx);\r\n    const textFieldHeight = this.measureHeight();\r\n    const x = (isShiftLeft ? this.anchor.x - textFieldWidth : this.anchor.x);\r\n    const y = isShiftTop ? this.anchor.y - textFieldHeight : this.anchor.y;\r\n\r\n    // adjust anchor if text box exceeds canvas borders\r\n    if (canvasDims) {\r\n      const { width, height } = canvasDims;\r\n      const newX = Math.max(Math.min(x, width - textFieldWidth), 0);\r\n      const newY = Math.max(Math.min(y, height - textFieldHeight), 0);\r\n      return { x: newX, y: newY };\r\n    }\r\n    return { x, y };\r\n  }\r\n\r\n  draw(canvasArg: string | HTMLCanvasElement | CanvasRenderingContext2D) {\r\n    const canvas = resolveInput(canvasArg);\r\n    const ctx = getContext2dOrThrow(canvas);\r\n\r\n    const {\r\n      backgroundColor, fontColor, fontSize, fontStyle, padding,\r\n    } = this.options;\r\n\r\n    ctx.font = `${fontSize}px ${fontStyle}`;\r\n    const maxTextWidth = this.measureWidth(ctx);\r\n    const textHeight = this.measureHeight();\r\n\r\n    ctx.fillStyle = backgroundColor;\r\n    const upperLeft = this.getUpperLeft(ctx, canvas);\r\n    ctx.fillRect(upperLeft.x, upperLeft.y, maxTextWidth, textHeight);\r\n\r\n    ctx.fillStyle = fontColor;\r\n    this.text.forEach((textLine, i) => {\r\n      const x = padding + upperLeft.x;\r\n      const y = padding + upperLeft.y + ((i + 1) * fontSize);\r\n      ctx.fillText(textLine, x, y);\r\n    });\r\n  }\r\n}\r\n", "/* eslint-disable max-classes-per-file */\r\nimport { Box, IBoundingBox, IRect } from '../classes/index';\r\nimport { getContext2dOrThrow } from '../dom/getContext2dOrThrow';\r\nimport {\r\n  AnchorPosition, DrawTextField, DrawTextFieldOptions, IDrawTextFieldOptions,\r\n} from './DrawTextField';\r\n\r\nexport interface IDrawBoxOptions {\r\n  boxColor?: string\r\n  lineWidth?: number\r\n  drawLabelOptions?: IDrawTextFieldOptions\r\n  label?: string\r\n}\r\n\r\nexport class DrawBoxOptions {\r\n  public boxColor: string\r\n\r\n  public lineWidth: number\r\n\r\n  public drawLabelOptions: DrawTextFieldOptions\r\n\r\n  public label?: string\r\n\r\n  constructor(options: IDrawBoxOptions = {}) {\r\n    const {\r\n      boxColor, lineWidth, label, drawLabelOptions,\r\n    } = options;\r\n    this.boxColor = boxColor || 'rgba(0, 0, 255, 1)';\r\n    this.lineWidth = lineWidth || 2;\r\n    this.label = label;\r\n\r\n    const defaultDrawLabelOptions = {\r\n      anchorPosition: AnchorPosition.BOTTOM_LEFT,\r\n      backgroundColor: this.boxColor,\r\n    };\r\n    this.drawLabelOptions = new DrawTextFieldOptions({ ...defaultDrawLabelOptions, ...drawLabelOptions });\r\n  }\r\n}\r\n\r\nexport class DrawBox {\r\n  public box: Box\r\n\r\n  public options: DrawBoxOptions\r\n\r\n  constructor(\r\n    box: IBoundingBox | IRect,\r\n    options: IDrawBoxOptions = {},\r\n  ) {\r\n    this.box = new Box(box);\r\n    this.options = new DrawBoxOptions(options);\r\n  }\r\n\r\n  draw(canvasArg: string | HTMLCanvasElement | CanvasRenderingContext2D) {\r\n    const ctx = getContext2dOrThrow(canvasArg);\r\n\r\n    const { boxColor, lineWidth } = this.options;\r\n\r\n    const {\r\n      x, y, width, height,\r\n    } = this.box;\r\n    ctx.strokeStyle = boxColor;\r\n    ctx.lineWidth = lineWidth;\r\n    ctx.strokeRect(x, y, width, height);\r\n\r\n    const { label } = this.options;\r\n    if (label) {\r\n      new DrawTextField([label], { x: x - (lineWidth / 2), y }, this.options.drawLabelOptions).draw(canvasArg);\r\n    }\r\n  }\r\n}\r\n", "import { Box, IBoundingBox, IRect } from '../classes/index';\r\nimport { FaceDetection } from '../classes/FaceDetection';\r\nimport { isWithFaceDetection, WithFaceDetection } from '../factories/WithFaceDetection';\r\nimport { round } from '../utils/index';\r\nimport { DrawBox } from './DrawBox';\r\n\r\nexport type TDrawDetectionsInput = IRect | IBoundingBox | FaceDetection | WithFaceDetection<{}>\r\n\r\nexport function drawDetections(\r\n  canvasArg: string | HTMLCanvasElement,\r\n  detections: TDrawDetectionsInput | Array<TDrawDetectionsInput>,\r\n) {\r\n  const detectionsArray = Array.isArray(detections) ? detections : [detections];\r\n\r\n  detectionsArray.forEach((det) => {\r\n    // eslint-disable-next-line no-nested-ternary\r\n    const score = det instanceof FaceDetection\r\n      ? det.score\r\n      : (isWithFaceDetection(det) ? det.detection.score : undefined);\r\n\r\n    // eslint-disable-next-line no-nested-ternary\r\n    const box = det instanceof FaceDetection\r\n      ? det.box\r\n      : (isWithFaceDetection(det) ? det.detection.box : new Box(det));\r\n\r\n    const label = score ? `${round(score)}` : undefined;\r\n    new DrawBox(box, { label }).draw(canvasArg);\r\n  });\r\n}\r\n", "import * as tf from '../../dist/tfjs.esm';\r\n\r\nimport { NetInput, TNetInput, toNetInput } from '../dom/index';\r\nimport { FaceFeatureExtractor } from '../faceFeatureExtractor/FaceFeatureExtractor';\r\nimport { FaceFeatureExtractorParams } from '../faceFeatureExtractor/types';\r\nimport { FaceProcessor } from '../faceProcessor/FaceProcessor';\r\nimport { FaceExpressions } from './FaceExpressions';\r\n\r\nexport class FaceExpressionNet extends FaceProcessor<FaceFeatureExtractorParams> {\r\n  constructor(faceFeatureExtractor: FaceFeatureExtractor = new FaceFeatureExtractor()) {\r\n    super('FaceExpressionNet', faceFeatureExtractor);\r\n  }\r\n\r\n  public forwardInput(input: NetInput | tf.Tensor4D): tf.Tensor2D {\r\n    return tf.tidy(() => tf.softmax(this.runNet(input)));\r\n  }\r\n\r\n  public async forward(input: TNetInput): Promise<tf.Tensor2D> {\r\n    return this.forwardInput(await toNetInput(input));\r\n  }\r\n\r\n  public async predictExpressions(input: TNetInput) {\r\n    const netInput = await toNetInput(input);\r\n    const out = await this.forwardInput(netInput);\r\n    const probabilitesByBatch = await Promise.all(tf.unstack(out).map(async (t) => {\r\n      const data = await t.data();\r\n      t.dispose();\r\n      return data;\r\n    }));\r\n    out.dispose();\r\n\r\n    const predictionsByBatch = probabilitesByBatch\r\n      .map((probabilites) => new FaceExpressions(probabilites as Float32Array));\r\n\r\n    return netInput.isBatchInput\r\n      ? predictionsByBatch\r\n      : predictionsByBatch[0];\r\n  }\r\n\r\n  protected getDefaultModelName(): string {\r\n    return 'face_expression_model';\r\n  }\r\n\r\n  protected getClassifierChannelsIn(): number {\r\n    return 256;\r\n  }\r\n\r\n  protected getClassifierChannelsOut(): number {\r\n    return 7;\r\n  }\r\n}\r\n", "import { env } from '../env/index';\r\n\r\nexport function isMediaLoaded(media: HTMLImageElement | HTMLVideoElement) : boolean {\r\n  const { Image, Video } = env.getEnv();\r\n\r\n  return (media instanceof Image && media.complete)\r\n    || (media instanceof Video && media.readyState >= 3);\r\n}\r\n", "import { env } from '../env/index';\r\nimport { isMediaLoaded } from './isMediaLoaded';\r\n\r\nexport function awaitMediaLoaded(media: HTMLImageElement | HTMLVideoElement | HTMLCanvasElement) {\r\n  // eslint-disable-next-line consistent-return\r\n  return new Promise((resolve, reject) => {\r\n    if (media instanceof env.getEnv().Canvas || isMediaLoaded(media)) {\r\n      return resolve(null);\r\n    }\r\n\r\n    function onError(e: Event) {\r\n      if (!e.currentTarget) return;\r\n      // eslint-disable-next-line no-use-before-define\r\n      e.currentTarget.removeEventListener('load', onLoad);\r\n      e.currentTarget.removeEventListener('error', onError);\r\n      reject(e);\r\n    }\r\n\r\n    function onLoad(e: Event) {\r\n      if (!e.currentTarget) return;\r\n      e.currentTarget.removeEventListener('load', onLoad);\r\n      e.currentTarget.removeEventListener('error', onError);\r\n      resolve(e);\r\n    }\r\n\r\n    media.addEventListener('load', onLoad);\r\n    media.addEventListener('error', onError);\r\n  });\r\n}\r\n", "import { env } from '../env/index';\r\n\r\nexport function bufferToImage(buf: Blob): Promise<HTMLImageElement> {\r\n  return new Promise((resolve, reject) => {\r\n    if (!(buf instanceof Blob)) reject(new Error('bufferToImage - expected buf to be of type: Blob'));\r\n    const reader = new FileReader();\r\n    reader.onload = () => {\r\n      if (typeof reader.result !== 'string') reject(new Error('bufferToImage - expected reader.result to be a string, in onload'));\r\n      const img = env.getEnv().createImageElement();\r\n      img.onload = () => resolve(img);\r\n      img.onerror = reject;\r\n      img.src = reader.result as string;\r\n    };\r\n    reader.onerror = reject;\r\n    reader.readAsDataURL(buf);\r\n  });\r\n}\r\n", "import { Dimensions, IDimensions } from '../classes/Dimensions';\r\nimport { env } from '../env/index';\r\n\r\nexport function getMediaDimensions(input: HTMLImageElement | HTMLCanvasElement | HTMLVideoElement | IDimensions): Dimensions {\r\n  const { Image, Video } = env.getEnv();\r\n\r\n  if (input instanceof Image) {\r\n    return new Dimensions(input.naturalWidth, input.naturalHeight);\r\n  }\r\n  if (input instanceof Video) {\r\n    return new Dimensions(input.videoWidth, input.videoHeight);\r\n  }\r\n  return new Dimensions(input.width, input.height);\r\n}\r\n", "import { IDimensions } from '../classes/Dimensions';\r\nimport { env } from '../env/index';\r\nimport { getContext2dOrThrow } from './getContext2dOrThrow';\r\nimport { getMediaDimensions } from './getMediaDimensions';\r\nimport { isMediaLoaded } from './isMediaLoaded';\r\n\r\nexport function createCanvas({ width, height }: IDimensions): HTMLCanvasElement {\r\n  const { createCanvasElement } = env.getEnv();\r\n  const canvas = createCanvasElement();\r\n  canvas.width = width;\r\n  canvas.height = height;\r\n  return canvas;\r\n}\r\n\r\nexport function createCanvasFromMedia(media: HTMLImageElement | HTMLVideoElement | ImageData, dims?: IDimensions): HTMLCanvasElement {\r\n  const { ImageData } = env.getEnv();\r\n\r\n  if (!(media instanceof ImageData) && !isMediaLoaded(media)) {\r\n    throw new Error('createCanvasFromMedia - media has not finished loading yet');\r\n  }\r\n\r\n  const { width, height } = dims || getMediaDimensions(media);\r\n  const canvas = createCanvas({ width, height });\r\n\r\n  if (media instanceof ImageData) {\r\n    getContext2dOrThrow(canvas).putImageData(media, 0, 0);\r\n  } else {\r\n    getContext2dOrThrow(canvas).drawImage(media, 0, 0, width, height);\r\n  }\r\n  return canvas;\r\n}\r\n", "import * as tf from '../../dist/tfjs.esm';\r\n\r\nimport { env } from '../env/index';\r\nimport { isTensor4D } from '../utils/index';\r\n\r\nexport async function imageTensorToCanvas(\r\n  imgTensor: tf.Tensor,\r\n  canvas?: HTMLCanvasElement,\r\n): Promise<HTMLCanvasElement> {\r\n  const targetCanvas = canvas || env.getEnv().createCanvasElement();\r\n\r\n  const [height, width, numChannels] = imgTensor.shape.slice(isTensor4D(imgTensor) ? 1 : 0);\r\n  const imgTensor3D = tf.tidy(() => imgTensor.as3D(height, width, numChannels).toInt());\r\n  await tf.browser.toPixels(imgTensor3D, targetCanvas);\r\n\r\n  imgTensor3D.dispose();\r\n\r\n  return targetCanvas;\r\n}\r\n", "import { env } from '../env/index';\r\n\r\nexport function isMediaElement(input: any) {\r\n  const { Image, Canvas, Video } = env.getEnv();\r\n\r\n  return input instanceof Image\r\n    || input instanceof Canvas\r\n    || input instanceof Video;\r\n}\r\n", "import * as tf from '../../dist/tfjs.esm';\r\n\r\nimport { Dimensions } from '../classes/Dimensions';\r\nimport { env } from '../env/index';\r\nimport { padToSquare } from '../ops/padToSquare';\r\nimport {\r\n  computeReshapedDimensions, isTensor3D, isTensor4D, range,\r\n} from '../utils/index';\r\nimport { createCanvasFromMedia } from './createCanvas';\r\nimport { imageToSquare } from './imageToSquare';\r\nimport { TResolvedNetInput } from './types';\r\n\r\nexport class NetInput {\r\n  private _imageTensors: Array<tf.Tensor3D | tf.Tensor4D> = []\r\n\r\n  private _canvases: HTMLCanvasElement[] = []\r\n\r\n  private _batchSize: number\r\n\r\n  private _treatAsBatchInput: boolean = false\r\n\r\n  private _inputDimensions: number[][] = []\r\n\r\n  private _inputSize: number\r\n\r\n  constructor(\r\n    inputs: Array<TResolvedNetInput>,\r\n    treatAsBatchInput: boolean = false,\r\n  ) {\r\n    if (!Array.isArray(inputs)) {\r\n      throw new Error(`NetInput.constructor - expected inputs to be an Array of TResolvedNetInput or to be instanceof tf.Tensor4D, instead have ${inputs}`);\r\n    }\r\n\r\n    this._treatAsBatchInput = treatAsBatchInput;\r\n    this._batchSize = inputs.length;\r\n\r\n    inputs.forEach((input, idx) => {\r\n      if (isTensor3D(input)) {\r\n        this._imageTensors[idx] = input;\r\n        this._inputDimensions[idx] = input.shape;\r\n        return;\r\n      }\r\n\r\n      if (isTensor4D(input)) {\r\n        const batchSize = (input as any).shape[0];\r\n        if (batchSize !== 1) {\r\n          throw new Error(`NetInput - tf.Tensor4D with batchSize ${batchSize} passed, but not supported in input array`);\r\n        }\r\n\r\n        this._imageTensors[idx] = input;\r\n        this._inputDimensions[idx] = (input as any).shape.slice(1);\r\n        return;\r\n      }\r\n\r\n      const canvas = (input as any) instanceof env.getEnv().Canvas ? input : createCanvasFromMedia(input);\r\n      this._canvases[idx] = canvas;\r\n      this._inputDimensions[idx] = [canvas.height, canvas.width, 3];\r\n    });\r\n  }\r\n\r\n  public get imageTensors(): Array<tf.Tensor3D | tf.Tensor4D> {\r\n    return this._imageTensors;\r\n  }\r\n\r\n  public get canvases(): HTMLCanvasElement[] {\r\n    return this._canvases;\r\n  }\r\n\r\n  public get isBatchInput(): boolean {\r\n    return this.batchSize > 1 || this._treatAsBatchInput;\r\n  }\r\n\r\n  public get batchSize(): number {\r\n    return this._batchSize;\r\n  }\r\n\r\n  public get inputDimensions(): number[][] {\r\n    return this._inputDimensions;\r\n  }\r\n\r\n  public get inputSize(): number | undefined {\r\n    return this._inputSize;\r\n  }\r\n\r\n  public get reshapedInputDimensions(): Dimensions[] {\r\n    return range(this.batchSize, 0, 1).map(\r\n      (_, batchIdx) => this.getReshapedInputDimensions(batchIdx),\r\n    );\r\n  }\r\n\r\n  public getInput(batchIdx: number): tf.Tensor3D | tf.Tensor4D | HTMLCanvasElement {\r\n    return this.canvases[batchIdx] || this.imageTensors[batchIdx];\r\n  }\r\n\r\n  public getInputDimensions(batchIdx: number): number[] {\r\n    return this._inputDimensions[batchIdx];\r\n  }\r\n\r\n  public getInputHeight(batchIdx: number): number {\r\n    return this._inputDimensions[batchIdx][0];\r\n  }\r\n\r\n  public getInputWidth(batchIdx: number): number {\r\n    return this._inputDimensions[batchIdx][1];\r\n  }\r\n\r\n  public getReshapedInputDimensions(batchIdx: number): Dimensions {\r\n    if (typeof this.inputSize !== 'number') {\r\n      throw new Error('getReshapedInputDimensions - inputSize not set, toBatchTensor has not been called yet');\r\n    }\r\n\r\n    const width = this.getInputWidth(batchIdx);\r\n    const height = this.getInputHeight(batchIdx);\r\n    return computeReshapedDimensions({ width, height }, this.inputSize);\r\n  }\r\n\r\n  /**\r\n   * Create a batch tensor from all input canvases and tensors\r\n   * with size [batchSize, inputSize, inputSize, 3].\r\n   *\r\n   * @param inputSize Height and width of the tensor.\r\n   * @param isCenterImage (optional, default: false) If true, add an equal amount of padding on\r\n   * both sides of the minor dimension oof the image.\r\n   * @returns The batch tensor.\r\n   */\r\n  public toBatchTensor(inputSize: number, isCenterInputs: boolean = true): tf.Tensor4D {\r\n    this._inputSize = inputSize;\r\n\r\n    return tf.tidy(() => {\r\n      const inputTensors = range(this.batchSize, 0, 1).map((batchIdx) => {\r\n        const input = this.getInput(batchIdx);\r\n\r\n        if (input instanceof tf.Tensor) {\r\n          // @ts-ignore: error TS2344: Type 'Rank.R4' does not satisfy the constraint 'Tensor<Rank>'.\r\n          let imgTensor = isTensor4D(input) ? input : input.expandDims<tf.Rank.R4>();\r\n          // @ts-ignore: error TS2344: Type 'Rank.R4' does not satisfy the constraint 'Tensor<Rank>'.\r\n          imgTensor = padToSquare(imgTensor, isCenterInputs);\r\n\r\n          if (imgTensor.shape[1] !== inputSize || imgTensor.shape[2] !== inputSize) {\r\n            imgTensor = tf.image.resizeBilinear(imgTensor, [inputSize, inputSize]);\r\n          }\r\n\r\n          return imgTensor.as3D(inputSize, inputSize, 3);\r\n        }\r\n\r\n        if (input instanceof env.getEnv().Canvas) {\r\n          return tf.browser.fromPixels(imageToSquare(input, inputSize, isCenterInputs));\r\n        }\r\n\r\n        throw new Error(`toBatchTensor - at batchIdx ${batchIdx}, expected input to be instanceof tf.Tensor or instanceof HTMLCanvasElement, instead have ${input}`);\r\n      });\r\n\r\n      // const batchTensor = tf.stack(inputTensors.map(t => t.toFloat())).as4D(this.batchSize, inputSize, inputSize, 3)\r\n      const batchTensor = tf.stack(inputTensors.map((t) => tf.cast(t, 'float32'))).as4D(this.batchSize, inputSize, inputSize, 3);\r\n      // const batchTensor = tf.stack(inputTensors.map(t => tf.Tensor.as4D(tf.cast(t, 'float32'))), this.batchSize, inputSize, inputSize, 3);\r\n\r\n      return batchTensor;\r\n    });\r\n  }\r\n}\r\n", "import { env } from '../env/index';\r\nimport { createCanvas, createCanvasFromMedia } from './createCanvas';\r\nimport { getContext2dOrThrow } from './getContext2dOrThrow';\r\nimport { getMediaDimensions } from './getMediaDimensions';\r\n\r\nexport function imageToSquare(input: HTMLImageElement | HTMLCanvasElement, inputSize: number, centerImage: boolean = false) {\r\n  const { Image, Canvas } = env.getEnv();\r\n\r\n  if (!(input instanceof Image || input instanceof Canvas)) {\r\n    throw new Error('imageToSquare - expected arg0 to be HTMLImageElement | HTMLCanvasElement');\r\n  }\r\n\r\n  const dims = getMediaDimensions(input);\r\n  const scale = inputSize / Math.max(dims.height, dims.width);\r\n  const width = scale * dims.width;\r\n  const height = scale * dims.height;\r\n\r\n  const targetCanvas = createCanvas({ width: inputSize, height: inputSize });\r\n  const inputCanvas = input instanceof Canvas ? input : createCanvasFromMedia(input);\r\n\r\n  const offset = Math.abs(width - height) / 2;\r\n  const dx = centerImage && width < height ? offset : 0;\r\n  const dy = centerImage && height < width ? offset : 0;\r\n  getContext2dOrThrow(targetCanvas).drawImage(inputCanvas, dx, dy, width, height);\r\n\r\n  return targetCanvas;\r\n}\r\n", "import { isTensor3D, isTensor4D } from '../utils/index';\r\nimport { awaitMediaLoaded } from './awaitMediaLoaded';\r\nimport { isMediaElement } from './isMediaElement';\r\nimport { NetInput } from './NetInput';\r\nimport { resolveInput } from './resolveInput';\r\nimport { TNetInput } from './types';\r\n\r\n/**\r\n * Validates the input to make sure, they are valid net inputs and awaits all media elements\r\n * to be finished loading.\r\n *\r\n * @param input The input, which can be a media element or an array of different media elements.\r\n * @returns A NetInput instance, which can be passed into one of the neural networks.\r\n */\r\nexport async function toNetInput(inputs: TNetInput): Promise<NetInput> {\r\n  if (inputs instanceof NetInput) {\r\n    return inputs;\r\n  }\r\n\r\n  const inputArgArray = Array.isArray(inputs)\r\n    ? inputs\r\n    : [inputs];\r\n\r\n  if (!inputArgArray.length) {\r\n    throw new Error('toNetInput - empty array passed as input');\r\n  }\r\n\r\n  const getIdxHint = (idx: number) => (Array.isArray(inputs) ? ` at input index ${idx}:` : '');\r\n\r\n  const inputArray = inputArgArray.map(resolveInput);\r\n\r\n  inputArray.forEach((input, i) => {\r\n    if (!isMediaElement(input) && !isTensor3D(input) && !isTensor4D(input)) {\r\n      if (typeof inputArgArray[i] === 'string') {\r\n        throw new Error(`toNetInput -${getIdxHint(i)} string passed, but could not resolve HTMLElement for element id ${inputArgArray[i]}`);\r\n      }\r\n\r\n      throw new Error(`toNetInput -${getIdxHint(i)} expected media to be of type HTMLImageElement | HTMLVideoElement | HTMLCanvasElement | tf.Tensor3D, or to be an element id`);\r\n    }\r\n\r\n    if (isTensor4D(input)) {\r\n      // if tf.Tensor4D is passed in the input array, the batch size has to be 1\r\n      const batchSize = input.shape[0];\r\n      if (batchSize !== 1) {\r\n        throw new Error(`toNetInput -${getIdxHint(i)} tf.Tensor4D with batchSize ${batchSize} passed, but not supported in input array`);\r\n      }\r\n    }\r\n  });\r\n\r\n  // wait for all media elements being loaded\r\n  await Promise.all(\r\n    inputArray.map((input) => isMediaElement(input) && awaitMediaLoaded(input)),\r\n  );\r\n\r\n  return new NetInput(inputArray, Array.isArray(inputs));\r\n}\r\n", "import { FaceDetection } from '../classes/FaceDetection';\r\nimport { Rect } from '../classes/Rect';\r\nimport { env } from '../env/index';\r\nimport { createCanvas } from './createCanvas';\r\nimport { getContext2dOrThrow } from './getContext2dOrThrow';\r\nimport { imageTensorToCanvas } from './imageTensorToCanvas';\r\nimport { toNetInput } from './toNetInput';\r\nimport { TNetInput } from './types';\r\n\r\n/**\r\n * Extracts the image regions containing the detected faces.\r\n *\r\n * @param input The image that face detection has been performed on.\r\n * @param detections The face detection results or face bounding boxes for that image.\r\n * @returns The Canvases of the corresponding image region for each detected face.\r\n */\r\nexport async function extractFaces(\r\n  input: TNetInput,\r\n  detections: Array<FaceDetection | Rect>,\r\n): Promise<HTMLCanvasElement[]> {\r\n  const { Canvas } = env.getEnv();\r\n\r\n  let canvas = input as HTMLCanvasElement;\r\n\r\n  if (!(input instanceof Canvas)) {\r\n    const netInput = await toNetInput(input);\r\n\r\n    if (netInput.batchSize > 1) {\r\n      throw new Error('extractFaces - batchSize > 1 not supported');\r\n    }\r\n\r\n    const tensorOrCanvas = netInput.getInput(0);\r\n    canvas = tensorOrCanvas instanceof Canvas\r\n      ? tensorOrCanvas\r\n      : await imageTensorToCanvas(tensorOrCanvas);\r\n  }\r\n\r\n  const ctx = getContext2dOrThrow(canvas);\r\n  const boxes = detections.map(\r\n    (det) => (det instanceof FaceDetection\r\n      ? det.forSize(canvas.width, canvas.height).box.floor()\r\n      : det),\r\n  )\r\n    .map((box) => box.clipAtImageBorders(canvas.width, canvas.height));\r\n\r\n  return boxes.map(({\r\n    x, y, width, height,\r\n  }) => {\r\n    const faceImg = createCanvas({ width, height });\r\n    getContext2dOrThrow(faceImg)\r\n      .putImageData(ctx.getImageData(x, y, width, height), 0, 0);\r\n    return faceImg;\r\n  });\r\n}\r\n", "import * as tf from '../../dist/tfjs.esm';\r\n\r\nimport { Rect } from '../classes/index';\r\nimport { FaceDetection } from '../classes/FaceDetection';\r\nimport { isTensor3D, isTensor4D } from '../utils/index';\r\n\r\n/**\r\n * Extracts the tensors of the image regions containing the detected faces.\r\n * Useful if you want to compute the face descriptors for the face images.\r\n * Using this method is faster then extracting a canvas for each face and\r\n * converting them to tensors individually.\r\n *\r\n * @param imageTensor The image tensor that face detection has been performed on.\r\n * @param detections The face detection results or face bounding boxes for that image.\r\n * @returns Tensors of the corresponding image region for each detected face.\r\n */\r\nexport async function extractFaceTensors(\r\n  imageTensor: tf.Tensor3D | tf.Tensor4D,\r\n  detections: Array<FaceDetection | Rect>,\r\n): Promise<tf.Tensor3D[]> {\r\n  if (!isTensor3D(imageTensor) && !isTensor4D(imageTensor)) {\r\n    throw new Error('extractFaceTensors - expected image tensor to be 3D or 4D');\r\n  }\r\n\r\n  if (isTensor4D(imageTensor) && imageTensor.shape[0] > 1) {\r\n    throw new Error('extractFaceTensors - batchSize > 1 not supported');\r\n  }\r\n\r\n  return tf.tidy(() => {\r\n    const [imgHeight, imgWidth, numChannels] = imageTensor.shape.slice(isTensor4D(imageTensor) ? 1 : 0);\r\n\r\n    const boxes = detections.map(\r\n      (det) => (det instanceof FaceDetection\r\n        ? det.forSize(imgWidth, imgHeight).box\r\n        : det),\r\n    )\r\n      .map((box) => box.clipAtImageBorders(imgWidth, imgHeight));\r\n\r\n    const faceTensors = boxes.map(({\r\n      x, y, width, height,\r\n    }) => tf.slice3d(imageTensor.as3D(imgHeight, imgWidth, numChannels), [y, x, 0], [height, width, numChannels]));\r\n\r\n    return faceTensors;\r\n  });\r\n}\r\n", "import { env } from '../env/index';\r\n\r\nexport async function fetchOrThrow(\r\n  url: string,\r\n  // eslint-disable-next-line no-undef\r\n  init?: RequestInit,\r\n): Promise<Response> {\r\n  const { fetch } = env.getEnv();\r\n  const res = await fetch(url, init);\r\n  if (!(res.status < 400)) {\r\n    throw new Error(`failed to fetch: (${res.status}) ${res.statusText}, from url: ${res.url}`);\r\n  }\r\n  return res;\r\n}\r\n", "import { bufferToImage } from './bufferToImage';\r\nimport { fetchOrThrow } from './fetchOrThrow';\r\n\r\nexport async function fetchImage(uri: string): Promise<HTMLImageElement> {\r\n  const res = await fetchOrThrow(uri);\r\n  const blob = await (res).blob();\r\n\r\n  if (!blob.type.startsWith('image/')) {\r\n    throw new Error(`fetchImage - expected blob type to be of type image/*, instead have: ${blob.type}, for url: ${res.url}`);\r\n  }\r\n  return bufferToImage(blob);\r\n}\r\n", "import { fetchOrThrow } from './fetchOrThrow';\r\n\r\nexport async function fetchJson<T>(uri: string): Promise<T> {\r\n  return (await fetchOrThrow(uri)).json();\r\n}\r\n", "import { fetchOrThrow } from './fetchOrThrow';\r\n\r\nexport async function fetchNetWeights(uri: string): Promise<Float32Array> {\r\n  return new Float32Array(await (await fetchOrThrow(uri)).arrayBuffer());\r\n}\r\n", "import * as tf from '../../dist/tfjs.esm';\r\n\r\nimport { getModelUris } from '../common/getModelUris';\r\nimport { fetchJson } from './fetchJson';\r\n\r\nexport async function loadWeightMap(\r\n  uri: string | undefined,\r\n  defaultModelName: string,\r\n): Promise<tf.NamedTensorMap> {\r\n  const { manifestUri, modelBaseUri } = getModelUris(uri, defaultModelName);\r\n  const manifest = await fetchJson<tf.io.WeightsManifestConfig>(manifestUri);\r\n  // if (manifest['weightsManifest']) manifest = manifest['weightsManifest'];\r\n  return tf.io.loadWeights(manifest, modelBaseUri);\r\n}\r\n", "export function getModelUris(uri: string | undefined, defaultModelName: string) {\r\n  const defaultManifestFilename = `${defaultModelName}-weights_manifest.json`;\r\n\r\n  if (!uri) {\r\n    return {\r\n      modelBaseUri: '',\r\n      manifestUri: defaultManifestFilename,\r\n    };\r\n  }\r\n\r\n  if (uri === '/') {\r\n    return {\r\n      modelBaseUri: '/',\r\n      manifestUri: `/${defaultManifestFilename}`,\r\n    };\r\n  }\r\n  // eslint-disable-next-line no-nested-ternary\r\n  const protocol = uri.startsWith('http://') ? 'http://' : uri.startsWith('https://') ? 'https://' : '';\r\n  uri = uri.replace(protocol, '');\r\n\r\n  const parts = uri.split('/').filter((s) => s);\r\n\r\n  const manifestFile = uri.endsWith('.json')\r\n    ? parts[parts.length - 1]\r\n    : defaultManifestFilename;\r\n\r\n  let modelBaseUri = protocol + (uri.endsWith('.json') ? parts.slice(0, parts.length - 1) : parts).join('/');\r\n  modelBaseUri = uri.startsWith('/') ? `/${modelBaseUri}` : modelBaseUri;\r\n\r\n  return {\r\n    modelBaseUri,\r\n    manifestUri: modelBaseUri === '/' ? `/${manifestFile}` : `${modelBaseUri}/${manifestFile}`,\r\n  };\r\n}\r\n", "import { IDimensions } from '../classes/index';\r\nimport { getMediaDimensions } from './getMediaDimensions';\r\n\r\nexport function matchDimensions(input: IDimensions, reference: IDimensions, useMediaDimensions: boolean = false) {\r\n  const { width, height } = useMediaDimensions\r\n    ? getMediaDimensions(reference)\r\n    : reference;\r\n  input.width = width;\r\n  input.height = height;\r\n  return { width, height };\r\n}\r\n", "import * as tf from '../../dist/tfjs.esm';\r\n\r\nimport { NetInput, TNetInput, toNetInput } from '../dom/index';\r\nimport { NeuralNetwork } from '../NeuralNetwork';\r\nimport { normalize } from '../ops/index';\r\nimport { denseBlock4 } from './denseBlock';\r\nimport { extractParams } from './extractParams';\r\nimport { extractParamsFromWeightMap } from './extractParamsFromWeightMap';\r\nimport { FaceFeatureExtractorParams, IFaceFeatureExtractor } from './types';\r\n\r\nexport class FaceFeatureExtractor extends NeuralNetwork<FaceFeatureExtractorParams> implements IFaceFeatureExtractor<FaceFeatureExtractorParams> {\r\n  constructor() {\r\n    super('FaceFeatureExtractor');\r\n  }\r\n\r\n  public forwardInput(input: NetInput): tf.Tensor4D {\r\n    const { params } = this;\r\n\r\n    if (!params) {\r\n      throw new Error('FaceFeatureExtractor - load model before inference');\r\n    }\r\n\r\n    return tf.tidy(() => {\r\n      const batchTensor = tf.cast(input.toBatchTensor(112, true), 'float32');\r\n      const meanRgb = [122.782, 117.001, 104.298];\r\n      const normalized = normalize(batchTensor, meanRgb).div(tf.scalar(255)) as tf.Tensor4D;\r\n\r\n      let out = denseBlock4(normalized, params.dense0, true);\r\n      out = denseBlock4(out, params.dense1);\r\n      out = denseBlock4(out, params.dense2);\r\n      out = denseBlock4(out, params.dense3);\r\n      out = tf.avgPool(out, [7, 7], [2, 2], 'valid');\r\n\r\n      return out;\r\n    });\r\n  }\r\n\r\n  public async forward(input: TNetInput): Promise<tf.Tensor4D> {\r\n    return this.forwardInput(await toNetInput(input));\r\n  }\r\n\r\n  protected getDefaultModelName(): string {\r\n    return 'face_feature_extractor_model';\r\n  }\r\n\r\n  protected extractParamsFromWeightMap(weightMap: tf.NamedTensorMap) {\r\n    return extractParamsFromWeightMap(weightMap);\r\n  }\r\n\r\n  protected extractParams(weights: Float32Array) {\r\n    return extractParams(weights);\r\n  }\r\n}\r\n", "import * as tf from '../dist/tfjs.esm';\r\n\r\nimport { ParamMapping } from './common/index';\r\nimport { getModelUris } from './common/getModelUris';\r\nimport { loadWeightMap } from './dom/index';\r\nimport { env } from './env/index';\r\n\r\nexport abstract class NeuralNetwork<TNetParams> {\r\n  constructor(name: string) {\r\n    this._name = name;\r\n  }\r\n\r\n  protected _params: TNetParams | undefined = undefined\r\n\r\n  protected _paramMappings: ParamMapping[] = []\r\n\r\n  public _name: any;\r\n\r\n  public get params(): TNetParams | undefined { return this._params; }\r\n\r\n  public get paramMappings(): ParamMapping[] { return this._paramMappings; }\r\n\r\n  public get isLoaded(): boolean { return !!this.params; }\r\n\r\n  public getParamFromPath(paramPath: string): tf.Tensor {\r\n    const { obj, objProp } = this.traversePropertyPath(paramPath);\r\n    return obj[objProp];\r\n  }\r\n\r\n  public reassignParamFromPath(paramPath: string, tensor: tf.Tensor) {\r\n    const { obj, objProp } = this.traversePropertyPath(paramPath);\r\n    obj[objProp].dispose();\r\n    obj[objProp] = tensor;\r\n  }\r\n\r\n  public getParamList() {\r\n    return this._paramMappings.map(({ paramPath }) => ({\r\n      path: paramPath,\r\n      tensor: this.getParamFromPath(paramPath),\r\n    }));\r\n  }\r\n\r\n  public getTrainableParams() {\r\n    return this.getParamList().filter((param) => param.tensor instanceof tf.Variable);\r\n  }\r\n\r\n  public getFrozenParams() {\r\n    return this.getParamList().filter((param) => !(param.tensor instanceof tf.Variable));\r\n  }\r\n\r\n  public variable() {\r\n    this.getFrozenParams().forEach(({ path, tensor }) => {\r\n      this.reassignParamFromPath(path, tensor.variable());\r\n    });\r\n  }\r\n\r\n  public freeze() {\r\n    this.getTrainableParams().forEach(({ path, tensor: variable }) => {\r\n      const tensor = tf.tensor(variable.dataSync());\r\n      variable.dispose();\r\n      this.reassignParamFromPath(path, tensor);\r\n    });\r\n  }\r\n\r\n  public dispose(throwOnRedispose: boolean = true) {\r\n    this.getParamList().forEach((param) => {\r\n      if (throwOnRedispose && param.tensor.isDisposed) {\r\n        throw new Error(`param tensor has already been disposed for path ${param.path}`);\r\n      }\r\n      param.tensor.dispose();\r\n    });\r\n    this._params = undefined;\r\n  }\r\n\r\n  public serializeParams(): Float32Array {\r\n    return new Float32Array(\r\n      this.getParamList()\r\n        .map(({ tensor }) => Array.from(tensor.dataSync()) as number[])\r\n        .reduce((flat, arr) => flat.concat(arr)),\r\n    );\r\n  }\r\n\r\n  public async load(weightsOrUrl: Float32Array | string | undefined): Promise<void> {\r\n    if (weightsOrUrl instanceof Float32Array) {\r\n      this.extractWeights(weightsOrUrl);\r\n      return;\r\n    }\r\n    await this.loadFromUri(weightsOrUrl);\r\n  }\r\n\r\n  public async loadFromUri(uri: string | undefined) {\r\n    if (uri && typeof uri !== 'string') {\r\n      throw new Error(`${this._name}.loadFromUri - expected model uri`);\r\n    }\r\n    const weightMap = await loadWeightMap(uri, this.getDefaultModelName());\r\n    this.loadFromWeightMap(weightMap);\r\n  }\r\n\r\n  public async loadFromDisk(filePath: string | undefined) {\r\n    if (filePath && typeof filePath !== 'string') {\r\n      throw new Error(`${this._name}.loadFromDisk - expected model file path`);\r\n    }\r\n    const { readFile } = env.getEnv();\r\n    const { manifestUri, modelBaseUri } = getModelUris(filePath, this.getDefaultModelName());\r\n    const fetchWeightsFromDisk = (filePaths: string[]) => Promise.all(filePaths.map((fp) => readFile(fp).then((buf) => buf.buffer)));\r\n    const loadWeights = tf.io.weightsLoaderFactory(fetchWeightsFromDisk);\r\n    const manifest = JSON.parse((await readFile(manifestUri)).toString());\r\n    const weightMap = await loadWeights(manifest, modelBaseUri);\r\n    this.loadFromWeightMap(weightMap);\r\n  }\r\n\r\n  public loadFromWeightMap(weightMap: tf.NamedTensorMap) {\r\n    const { paramMappings, params } = this.extractParamsFromWeightMap(weightMap);\r\n    this._paramMappings = paramMappings;\r\n    this._params = params;\r\n  }\r\n\r\n  public extractWeights(weights: Float32Array) {\r\n    const { paramMappings, params } = this.extractParams(weights);\r\n    this._paramMappings = paramMappings;\r\n    this._params = params;\r\n  }\r\n\r\n  private traversePropertyPath(paramPath: string) {\r\n    if (!this.params) {\r\n      throw new Error('traversePropertyPath - model has no loaded params');\r\n    }\r\n\r\n    const result = paramPath.split('/').reduce((res: { nextObj: any, obj?: any, objProp?: string }, objProp) => {\r\n      // eslint-disable-next-line no-prototype-builtins\r\n      if (!res.nextObj.hasOwnProperty(objProp)) {\r\n        throw new Error(`traversePropertyPath - object does not have property ${objProp}, for path ${paramPath}`);\r\n      }\r\n      return { obj: res.nextObj, objProp, nextObj: res.nextObj[objProp] };\r\n    }, { nextObj: this.params });\r\n\r\n    const { obj, objProp } = result;\r\n    if (!obj || !objProp || !(obj[objProp] instanceof tf.Tensor)) {\r\n      throw new Error(`traversePropertyPath - parameter is not a tensor, for path ${paramPath}`);\r\n    }\r\n\r\n    return { obj, objProp };\r\n  }\r\n\r\n  protected abstract getDefaultModelName(): string\r\n\r\n  // eslint-disable-next-line no-unused-vars\r\n  protected abstract extractParamsFromWeightMap(weightMap: tf.NamedTensorMap): { params: TNetParams, paramMappings: ParamMapping[] }\r\n\r\n  // eslint-disable-next-line no-unused-vars\r\n  protected abstract extractParams(weights: Float32Array): { params: TNetParams, paramMappings: ParamMapping[] }\r\n}\r\n", "import * as tf from '../../dist/tfjs.esm';\r\n\r\nimport { ConvParams, SeparableConvParams } from '../common/index';\r\nimport { depthwiseSeparableConv } from '../common/depthwiseSeparableConv';\r\nimport { DenseBlock3Params, DenseBlock4Params } from './types';\r\n\r\nexport function denseBlock3(\r\n  x: tf.Tensor4D,\r\n  denseBlockParams: DenseBlock3Params,\r\n  isFirstLayer: boolean = false,\r\n): tf.Tensor4D {\r\n  return tf.tidy(() => {\r\n    const out1 = tf.relu(\r\n      isFirstLayer\r\n        ? tf.add(\r\n          tf.conv2d(x, (denseBlockParams.conv0 as ConvParams).filters, [2, 2], 'same'),\r\n          denseBlockParams.conv0.bias,\r\n        )\r\n        : depthwiseSeparableConv(x, denseBlockParams.conv0 as SeparableConvParams, [2, 2]),\r\n    ) as tf.Tensor4D;\r\n    const out2 = depthwiseSeparableConv(out1, denseBlockParams.conv1, [1, 1]);\r\n\r\n    const in3 = tf.relu(tf.add(out1, out2)) as tf.Tensor4D;\r\n    const out3 = depthwiseSeparableConv(in3, denseBlockParams.conv2, [1, 1]);\r\n\r\n    return tf.relu(tf.add(out1, tf.add(out2, out3))) as tf.Tensor4D;\r\n  });\r\n}\r\n\r\nexport function denseBlock4(\r\n  x: tf.Tensor4D,\r\n  denseBlockParams: DenseBlock4Params,\r\n  isFirstLayer: boolean = false,\r\n  isScaleDown: boolean = true,\r\n): tf.Tensor4D {\r\n  return tf.tidy(() => {\r\n    const out1 = tf.relu(\r\n      isFirstLayer\r\n        ? tf.add(\r\n          tf.conv2d(x, (denseBlockParams.conv0 as ConvParams).filters, isScaleDown ? [2, 2] : [1, 1], 'same'),\r\n          denseBlockParams.conv0.bias,\r\n        )\r\n        : depthwiseSeparableConv(x, denseBlockParams.conv0 as SeparableConvParams, isScaleDown ? [2, 2] : [1, 1]),\r\n    ) as tf.Tensor4D;\r\n    const out2 = depthwiseSeparableConv(out1, denseBlockParams.conv1, [1, 1]);\r\n\r\n    const in3 = tf.relu(tf.add(out1, out2)) as tf.Tensor4D;\r\n    const out3 = depthwiseSeparableConv(in3, denseBlockParams.conv2, [1, 1]);\r\n\r\n    const in4 = tf.relu(tf.add(out1, tf.add(out2, out3))) as tf.Tensor4D;\r\n    const out4 = depthwiseSeparableConv(in4, denseBlockParams.conv3, [1, 1]);\r\n\r\n    return tf.relu(tf.add(out1, tf.add(out2, tf.add(out3, out4)))) as tf.Tensor4D;\r\n  });\r\n}\r\n", "import * as tf from '../../dist/tfjs.esm';\r\n\r\nimport { SeparableConvParams } from './types';\r\n\r\nexport function depthwiseSeparableConv(\r\n  x: tf.Tensor4D,\r\n  params: SeparableConvParams,\r\n  stride: [number, number],\r\n): tf.Tensor4D {\r\n  return tf.tidy(() => {\r\n    let out = tf.separableConv2d(x, params.depthwise_filter, params.pointwise_filter, stride, 'same');\r\n    out = tf.add(out, params.bias);\r\n    return out;\r\n  });\r\n}\r\n", "import * as tf from '../../dist/tfjs.esm';\r\n\r\nimport { ConvParams } from './types';\r\n\r\nexport function convLayer(\r\n  x: tf.Tensor4D,\r\n  params: ConvParams,\r\n  padding: 'valid' | 'same' = 'same',\r\n  withRelu: boolean = false,\r\n): tf.Tensor4D {\r\n  return tf.tidy(() => {\r\n    const out = tf.add(\r\n      tf.conv2d(x, params.filters, [1, 1], padding),\r\n      params.bias,\r\n    ) as tf.Tensor4D;\r\n\r\n    return withRelu ? tf.relu(out) : out;\r\n  });\r\n}\r\n", "import { ParamMapping } from './types';\r\n\r\nexport function disposeUnusedWeightTensors(weightMap: any, paramMappings: ParamMapping[]) {\r\n  Object.keys(weightMap).forEach((path) => {\r\n    if (!paramMappings.some((pm) => pm.originalPath === path)) {\r\n      weightMap[path].dispose();\r\n    }\r\n  });\r\n}\r\n", "import * as tf from '../../dist/tfjs.esm';\r\n\r\nimport { ConvParams, ExtractWeightsFunction, ParamMapping } from './types';\r\n\r\nexport function extractConvParamsFactory(\r\n  extractWeights: ExtractWeightsFunction,\r\n  paramMappings: ParamMapping[],\r\n) {\r\n  return (\r\n    channelsIn: number,\r\n    channelsOut: number,\r\n    filterSize: number,\r\n    mappedPrefix: string,\r\n  ): ConvParams => {\r\n    const filters = tf.tensor4d(\r\n      extractWeights(channelsIn * channelsOut * filterSize * filterSize),\r\n      [filterSize, filterSize, channelsIn, channelsOut],\r\n    );\r\n    const bias = tf.tensor1d(extractWeights(channelsOut));\r\n\r\n    paramMappings.push(\r\n      { paramPath: `${mappedPrefix}/filters` },\r\n      { paramPath: `${mappedPrefix}/bias` },\r\n    );\r\n\r\n    return { filters, bias };\r\n  };\r\n}\r\n", "import * as tf from '../../dist/tfjs.esm';\r\n\r\nimport { ExtractWeightsFunction, FCParams, ParamMapping } from './types';\r\n\r\nexport function extractFCParamsFactory(\r\n  extractWeights: ExtractWeightsFunction,\r\n  paramMappings: ParamMapping[],\r\n) {\r\n  return (\r\n    channelsIn: number,\r\n    channelsOut: number,\r\n    mappedPrefix: string,\r\n  ): FCParams => {\r\n    const fc_weights = tf.tensor2d(extractWeights(channelsIn * channelsOut), [channelsIn, channelsOut]);\r\n    const fc_bias = tf.tensor1d(extractWeights(channelsOut));\r\n\r\n    paramMappings.push(\r\n      { paramPath: `${mappedPrefix}/weights` },\r\n      { paramPath: `${mappedPrefix}/bias` },\r\n    );\r\n\r\n    return {\r\n      weights: fc_weights,\r\n      bias: fc_bias,\r\n    };\r\n  };\r\n}\r\n", "import * as tf from '../../dist/tfjs.esm';\r\n\r\nimport { ExtractWeightsFunction, ParamMapping, SeparableConvParams } from './types';\r\n\r\nexport function extractSeparableConvParamsFactory(\r\n  extractWeights: ExtractWeightsFunction,\r\n  paramMappings: ParamMapping[],\r\n) {\r\n  return (channelsIn: number, channelsOut: number, mappedPrefix: string): SeparableConvParams => {\r\n    const depthwise_filter = tf.tensor4d(extractWeights(3 * 3 * channelsIn), [3, 3, channelsIn, 1]);\r\n    const pointwise_filter = tf.tensor4d(extractWeights(channelsIn * channelsOut), [1, 1, channelsIn, channelsOut]);\r\n    const bias = tf.tensor1d(extractWeights(channelsOut));\r\n\r\n    paramMappings.push(\r\n      { paramPath: `${mappedPrefix}/depthwise_filter` },\r\n      { paramPath: `${mappedPrefix}/pointwise_filter` },\r\n      { paramPath: `${mappedPrefix}/bias` },\r\n    );\r\n\r\n    return new SeparableConvParams(\r\n      depthwise_filter,\r\n      pointwise_filter,\r\n      bias,\r\n    );\r\n  };\r\n}\r\n\r\nexport function loadSeparableConvParamsFactory(\r\n  // eslint-disable-next-line no-unused-vars\r\n  extractWeightEntry: <T>(originalPath: string, paramRank: number) => T,\r\n) {\r\n  return (prefix: string): SeparableConvParams => {\r\n    const depthwise_filter = extractWeightEntry<tf.Tensor4D>(`${prefix}/depthwise_filter`, 4);\r\n    const pointwise_filter = extractWeightEntry<tf.Tensor4D>(`${prefix}/pointwise_filter`, 4);\r\n    const bias = extractWeightEntry<tf.Tensor1D>(`${prefix}/bias`, 1);\r\n\r\n    return new SeparableConvParams(\r\n      depthwise_filter,\r\n      pointwise_filter,\r\n      bias,\r\n    );\r\n  };\r\n}\r\n", "import * as tf from '../../dist/tfjs.esm';\r\n\r\n// eslint-disable-next-line no-unused-vars\r\nexport type ExtractWeightsFunction = (numWeights: number) => Float32Array\r\n\r\nexport type ParamMapping = {\r\n  originalPath?: string\r\n  paramPath: string\r\n}\r\n\r\nexport type ConvParams = {\r\n  filters: tf.Tensor4D\r\n  bias: tf.Tensor1D\r\n}\r\n\r\nexport type FCParams = {\r\n  weights: tf.Tensor2D\r\n  bias: tf.Tensor1D\r\n}\r\n\r\nexport class SeparableConvParams {\r\n  // eslint-disable-next-line no-useless-constructor\r\n  constructor(\r\n    // eslint-disable-next-line no-unused-vars\r\n    public depthwise_filter: tf.Tensor4D,\r\n    // eslint-disable-next-line no-unused-vars\r\n    public pointwise_filter: tf.Tensor4D,\r\n    // eslint-disable-next-line no-unused-vars\r\n    public bias: tf.Tensor1D,\r\n  // eslint-disable-next-line no-empty-function\r\n  ) {}\r\n}\r\n", "import { isTensor } from '../utils/index';\r\nimport { ParamMapping } from './types';\r\n\r\nexport function extractWeightEntryFactory(weightMap: any, paramMappings: ParamMapping[]) {\r\n  return (originalPath: string, paramRank: number, mappedPath?: string) => {\r\n    const tensor = weightMap[originalPath];\r\n\r\n    if (!isTensor(tensor, paramRank)) {\r\n      throw new Error(`expected weightMap[${originalPath}] to be a Tensor${paramRank}D, instead have ${tensor}`);\r\n    }\r\n\r\n    paramMappings.push(\r\n      { originalPath, paramPath: mappedPath || originalPath },\r\n    );\r\n\r\n    return tensor;\r\n  };\r\n}\r\n", "export function extractWeightsFactory(weights: Float32Array) {\r\n  let remainingWeights = weights;\r\n\r\n  function extractWeights(numWeights: number): Float32Array {\r\n    const ret = remainingWeights.slice(0, numWeights);\r\n    remainingWeights = remainingWeights.slice(numWeights);\r\n    return ret;\r\n  }\r\n\r\n  function getRemainingWeights(): Float32Array {\r\n    return remainingWeights;\r\n  }\r\n\r\n  return {\r\n    extractWeights,\r\n    getRemainingWeights,\r\n  };\r\n}\r\n", "import {\r\n  extractConvParamsFactory,\r\n  extractSeparableConvParamsFactory,\r\n  ExtractWeightsFunction,\r\n  ParamMapping,\r\n} from '../common/index';\r\nimport { DenseBlock3Params, DenseBlock4Params } from './types';\r\n\r\nexport function extractorsFactory(extractWeights: ExtractWeightsFunction, paramMappings: ParamMapping[]) {\r\n  const extractConvParams = extractConvParamsFactory(extractWeights, paramMappings);\r\n  const extractSeparableConvParams = extractSeparableConvParamsFactory(extractWeights, paramMappings);\r\n\r\n  function extractDenseBlock3Params(channelsIn: number, channelsOut: number, mappedPrefix: string, isFirstLayer: boolean = false): DenseBlock3Params {\r\n    const conv0 = isFirstLayer\r\n      ? extractConvParams(channelsIn, channelsOut, 3, `${mappedPrefix}/conv0`)\r\n      : extractSeparableConvParams(channelsIn, channelsOut, `${mappedPrefix}/conv0`);\r\n    const conv1 = extractSeparableConvParams(channelsOut, channelsOut, `${mappedPrefix}/conv1`);\r\n    const conv2 = extractSeparableConvParams(channelsOut, channelsOut, `${mappedPrefix}/conv2`);\r\n\r\n    return { conv0, conv1, conv2 };\r\n  }\r\n\r\n  function extractDenseBlock4Params(channelsIn: number, channelsOut: number, mappedPrefix: string, isFirstLayer: boolean = false): DenseBlock4Params {\r\n    const { conv0, conv1, conv2 } = extractDenseBlock3Params(channelsIn, channelsOut, mappedPrefix, isFirstLayer);\r\n    const conv3 = extractSeparableConvParams(channelsOut, channelsOut, `${mappedPrefix}/conv3`);\r\n\r\n    return {\r\n      conv0, conv1, conv2, conv3,\r\n    };\r\n  }\r\n\r\n  return {\r\n    extractDenseBlock3Params,\r\n    extractDenseBlock4Params,\r\n  };\r\n}\r\n", "import { extractWeightsFactory, ParamMapping } from '../common/index';\r\nimport { extractorsFactory } from './extractorsFactory';\r\nimport { FaceFeatureExtractorParams } from './types';\r\n\r\nexport function extractParams(weights: Float32Array): { params: FaceFeatureExtractorParams, paramMappings: ParamMapping[] } {\r\n  const paramMappings: ParamMapping[] = [];\r\n\r\n  const {\r\n    extractWeights,\r\n    getRemainingWeights,\r\n  } = extractWeightsFactory(weights);\r\n\r\n  const {\r\n    extractDenseBlock4Params,\r\n  } = extractorsFactory(extractWeights, paramMappings);\r\n\r\n  const dense0 = extractDenseBlock4Params(3, 32, 'dense0', true);\r\n  const dense1 = extractDenseBlock4Params(32, 64, 'dense1');\r\n  const dense2 = extractDenseBlock4Params(64, 128, 'dense2');\r\n  const dense3 = extractDenseBlock4Params(128, 256, 'dense3');\r\n\r\n  if (getRemainingWeights().length !== 0) {\r\n    throw new Error(`weights remaing after extract: ${getRemainingWeights().length}`);\r\n  }\r\n\r\n  return {\r\n    paramMappings,\r\n    params: {\r\n      dense0, dense1, dense2, dense3,\r\n    },\r\n  };\r\n}\r\n", "import * as tf from '../../dist/tfjs.esm';\r\n\r\nimport { ConvParams } from './types';\r\n\r\n// eslint-disable-next-line no-unused-vars\r\nexport function loadConvParamsFactory(extractWeightEntry: <T>(originalPath: string, paramRank: number) => T) {\r\n  return (prefix: string): ConvParams => {\r\n    const filters = extractWeightEntry<tf.Tensor4D>(`${prefix}/filters`, 4);\r\n    const bias = extractWeightEntry<tf.Tensor1D>(`${prefix}/bias`, 1);\r\n\r\n    return { filters, bias };\r\n  };\r\n}\r\n", "import { extractWeightEntryFactory, loadSeparableConvParamsFactory, ParamMapping } from '../common/index';\r\nimport { loadConvParamsFactory } from '../common/loadConvParamsFactory';\r\nimport { DenseBlock3Params, DenseBlock4Params } from './types';\r\n\r\nexport function loadParamsFactory(weightMap: any, paramMappings: ParamMapping[]) {\r\n  const extractWeightEntry = extractWeightEntryFactory(weightMap, paramMappings);\r\n\r\n  const extractConvParams = loadConvParamsFactory(extractWeightEntry);\r\n  const extractSeparableConvParams = loadSeparableConvParamsFactory(extractWeightEntry);\r\n\r\n  function extractDenseBlock3Params(prefix: string, isFirstLayer: boolean = false): DenseBlock3Params {\r\n    const conv0 = isFirstLayer\r\n      ? extractConvParams(`${prefix}/conv0`)\r\n      : extractSeparableConvParams(`${prefix}/conv0`);\r\n    const conv1 = extractSeparableConvParams(`${prefix}/conv1`);\r\n    const conv2 = extractSeparableConvParams(`${prefix}/conv2`);\r\n\r\n    return { conv0, conv1, conv2 };\r\n  }\r\n\r\n  function extractDenseBlock4Params(prefix: string, isFirstLayer: boolean = false): DenseBlock4Params {\r\n    const conv0 = isFirstLayer\r\n      ? extractConvParams(`${prefix}/conv0`)\r\n      : extractSeparableConvParams(`${prefix}/conv0`);\r\n    const conv1 = extractSeparableConvParams(`${prefix}/conv1`);\r\n    const conv2 = extractSeparableConvParams(`${prefix}/conv2`);\r\n    const conv3 = extractSeparableConvParams(`${prefix}/conv3`);\r\n\r\n    return {\r\n      conv0, conv1, conv2, conv3,\r\n    };\r\n  }\r\n\r\n  return {\r\n    extractDenseBlock3Params,\r\n    extractDenseBlock4Params,\r\n  };\r\n}\r\n", "import * as tf from '../../dist/tfjs.esm';\r\n\r\nimport { disposeUnusedWeightTensors, ParamMapping } from '../common/index';\r\nimport { loadParamsFactory } from './loadParamsFactory';\r\nimport { FaceFeatureExtractorParams } from './types';\r\n\r\nexport function extractParamsFromWeightMap(\r\n  weightMap: tf.NamedTensorMap,\r\n): { params: FaceFeatureExtractorParams, paramMappings: ParamMapping[] } {\r\n  const paramMappings: ParamMapping[] = [];\r\n\r\n  const {\r\n    extractDenseBlock4Params,\r\n  } = loadParamsFactory(weightMap, paramMappings);\r\n\r\n  const params = {\r\n    dense0: extractDenseBlock4Params('dense0', true),\r\n    dense1: extractDenseBlock4Params('dense1'),\r\n    dense2: extractDenseBlock4Params('dense2'),\r\n    dense3: extractDenseBlock4Params('dense3'),\r\n  };\r\n\r\n  disposeUnusedWeightTensors(weightMap, paramMappings);\r\n\r\n  return { params, paramMappings };\r\n}\r\n", "import * as tf from '../../dist/tfjs.esm';\r\n\r\nimport { fullyConnectedLayer } from '../common/fullyConnectedLayer';\r\nimport { NetInput } from '../dom/index';\r\nimport {\r\n  FaceFeatureExtractorParams,\r\n  IFaceFeatureExtractor,\r\n  TinyFaceFeatureExtractorParams,\r\n} from '../faceFeatureExtractor/types';\r\nimport { NeuralNetwork } from '../NeuralNetwork';\r\nimport { extractParams } from './extractParams';\r\nimport { extractParamsFromWeightMap } from './extractParamsFromWeightMap';\r\nimport { NetParams } from './types';\r\nimport { seperateWeightMaps } from './util';\r\n\r\nexport abstract class FaceProcessor<\r\n  TExtractorParams extends FaceFeatureExtractorParams | TinyFaceFeatureExtractorParams\r\n>\r\n  extends NeuralNetwork<NetParams> {\r\n  protected _faceFeatureExtractor: IFaceFeatureExtractor<TExtractorParams>\r\n\r\n  constructor(_name: string, faceFeatureExtractor: IFaceFeatureExtractor<TExtractorParams>) {\r\n    super(_name);\r\n    this._faceFeatureExtractor = faceFeatureExtractor;\r\n  }\r\n\r\n  public get faceFeatureExtractor(): IFaceFeatureExtractor<TExtractorParams> {\r\n    return this._faceFeatureExtractor;\r\n  }\r\n\r\n  protected abstract getDefaultModelName(): string\r\n\r\n  protected abstract getClassifierChannelsIn(): number\r\n\r\n  protected abstract getClassifierChannelsOut(): number\r\n\r\n  public runNet(input: NetInput | tf.Tensor4D): tf.Tensor2D {\r\n    const { params } = this;\r\n\r\n    if (!params) {\r\n      throw new Error(`${this._name} - load model before inference`);\r\n    }\r\n\r\n    return tf.tidy(() => {\r\n      const bottleneckFeatures = input instanceof NetInput\r\n        ? this.faceFeatureExtractor.forwardInput(input)\r\n        : input;\r\n      return fullyConnectedLayer(bottleneckFeatures.as2D(bottleneckFeatures.shape[0], -1), params.fc);\r\n    });\r\n  }\r\n\r\n  public dispose(throwOnRedispose: boolean = true) {\r\n    this.faceFeatureExtractor.dispose(throwOnRedispose);\r\n    super.dispose(throwOnRedispose);\r\n  }\r\n\r\n  public loadClassifierParams(weights: Float32Array) {\r\n    const { params, paramMappings } = this.extractClassifierParams(weights);\r\n    this._params = params;\r\n    this._paramMappings = paramMappings;\r\n  }\r\n\r\n  public extractClassifierParams(weights: Float32Array) {\r\n    return extractParams(weights, this.getClassifierChannelsIn(), this.getClassifierChannelsOut());\r\n  }\r\n\r\n  protected extractParamsFromWeightMap(weightMap: tf.NamedTensorMap) {\r\n    const { featureExtractorMap, classifierMap } = seperateWeightMaps(weightMap);\r\n\r\n    this.faceFeatureExtractor.loadFromWeightMap(featureExtractorMap);\r\n\r\n    return extractParamsFromWeightMap(classifierMap);\r\n  }\r\n\r\n  protected extractParams(weights: Float32Array) {\r\n    const cIn = this.getClassifierChannelsIn();\r\n    const cOut = this.getClassifierChannelsOut();\r\n    const classifierWeightSize = (cOut * cIn) + cOut;\r\n\r\n    const featureExtractorWeights = weights.slice(0, weights.length - classifierWeightSize);\r\n    const classifierWeights = weights.slice(weights.length - classifierWeightSize);\r\n\r\n    this.faceFeatureExtractor.extractWeights(featureExtractorWeights);\r\n    return this.extractClassifierParams(classifierWeights);\r\n  }\r\n}\r\n", "import * as tf from '../../dist/tfjs.esm';\r\n\r\nimport { FCParams } from './types';\r\n\r\nexport function fullyConnectedLayer(\r\n  x: tf.Tensor2D,\r\n  params: FCParams,\r\n): tf.Tensor2D {\r\n  return tf.tidy(() => tf.add(\r\n    tf.matMul(x, params.weights),\r\n    params.bias,\r\n  ));\r\n}\r\n", "import { extractFCParamsFactory, extractWeightsFactory, ParamMapping } from '../common/index';\r\nimport { NetParams } from './types';\r\n\r\nexport function extractParams(weights: Float32Array, channelsIn: number, channelsOut: number): { params: NetParams, paramMappings: ParamMapping[] } {\r\n  const paramMappings: ParamMapping[] = [];\r\n\r\n  const {\r\n    extractWeights,\r\n    getRemainingWeights,\r\n  } = extractWeightsFactory(weights);\r\n\r\n  const extractFCParams = extractFCParamsFactory(extractWeights, paramMappings);\r\n\r\n  const fc = extractFCParams(channelsIn, channelsOut, 'fc');\r\n\r\n  if (getRemainingWeights().length !== 0) {\r\n    throw new Error(`weights remaing after extract: ${getRemainingWeights().length}`);\r\n  }\r\n\r\n  return {\r\n    paramMappings,\r\n    params: { fc },\r\n  };\r\n}\r\n", "import * as tf from '../../dist/tfjs.esm';\r\n\r\nimport {\r\n  disposeUnusedWeightTensors, extractWeightEntryFactory, FCParams, ParamMapping,\r\n} from '../common/index';\r\nimport { NetParams } from './types';\r\n\r\nexport function extractParamsFromWeightMap(\r\n  weightMap: tf.NamedTensorMap,\r\n): { params: NetParams, paramMappings: ParamMapping[] } {\r\n  const paramMappings: ParamMapping[] = [];\r\n\r\n  const extractWeightEntry = extractWeightEntryFactory(weightMap, paramMappings);\r\n\r\n  function extractFcParams(prefix: string): FCParams {\r\n    const weights = extractWeightEntry(`${prefix}/weights`, 2);\r\n    const bias = extractWeightEntry(`${prefix}/bias`, 1);\r\n    return { weights, bias };\r\n  }\r\n\r\n  const params = {\r\n    fc: extractFcParams('fc'),\r\n  };\r\n\r\n  disposeUnusedWeightTensors(weightMap, paramMappings);\r\n\r\n  return { params, paramMappings };\r\n}\r\n", "import * as tf from '../../dist/tfjs.esm';\r\n\r\nexport function seperateWeightMaps(weightMap: tf.NamedTensorMap) {\r\n  const featureExtractorMap: tf.NamedTensorMap = {};\r\n  const classifierMap: tf.NamedTensorMap = {};\r\n\r\n  Object.keys(weightMap).forEach((key) => {\r\n    const map = key.startsWith('fc') ? classifierMap : featureExtractorMap;\r\n    map[key] = weightMap[key];\r\n  });\r\n\r\n  return { featureExtractorMap, classifierMap };\r\n}\r\n", "export const FACE_EXPRESSION_LABELS = ['neutral', 'happy', 'sad', 'angry', 'fearful', 'disgusted', 'surprised'];\r\n\r\nexport class FaceExpressions {\r\n  public neutral: number\r\n\r\n  public happy: number\r\n\r\n  public sad: number\r\n\r\n  public angry: number\r\n\r\n  public fearful: number\r\n\r\n  public disgusted: number\r\n\r\n  public surprised: number\r\n\r\n  constructor(probabilities: number[] | Float32Array) {\r\n    if (probabilities.length !== 7) {\r\n      throw new Error(`FaceExpressions.constructor - expected probabilities.length to be 7, have: ${probabilities.length}`);\r\n    }\r\n\r\n    FACE_EXPRESSION_LABELS.forEach((expression, idx) => {\r\n      this[expression] = probabilities[idx];\r\n    });\r\n  }\r\n\r\n  asSortedArray() {\r\n    return FACE_EXPRESSION_LABELS\r\n      .map((expression) => ({ expression, probability: this[expression] as number }))\r\n      .sort((e0, e1) => e1.probability - e0.probability);\r\n  }\r\n}\r\n", "import { FaceExpressions } from '../faceExpressionNet/FaceExpressions';\r\n\r\nexport type WithFaceExpressions<TSource> = TSource & {\r\n  expressions: FaceExpressions\r\n}\r\n\r\nexport function isWithFaceExpressions(obj: any): obj is WithFaceExpressions<{}> {\r\n  return obj.expressions instanceof FaceExpressions;\r\n}\r\n\r\nexport function extendWithFaceExpressions<\r\n  TSource\r\n>(\r\n  sourceObj: TSource,\r\n  expressions: FaceExpressions,\r\n): WithFaceExpressions<TSource> {\r\n  const extension = { expressions };\r\n  return { ...sourceObj, ...extension };\r\n}\r\n", "import { IPoint, Point } from '../classes/index';\r\nimport { FaceExpressions } from '../faceExpressionNet/index';\r\nimport { isWithFaceDetection } from '../factories/WithFaceDetection';\r\nimport { isWithFaceExpressions, WithFaceExpressions } from '../factories/WithFaceExpressions';\r\nimport { round } from '../utils/index';\r\nimport { DrawTextField } from './DrawTextField';\r\n\r\nexport type DrawFaceExpressionsInput = FaceExpressions | WithFaceExpressions<{}>\r\n\r\nexport function drawFaceExpressions(\r\n  canvasArg: string | HTMLCanvasElement,\r\n  faceExpressions: DrawFaceExpressionsInput | Array<DrawFaceExpressionsInput>,\r\n  minConfidence = 0.1,\r\n  textFieldAnchor?: IPoint,\r\n) {\r\n  const faceExpressionsArray = Array.isArray(faceExpressions) ? faceExpressions : [faceExpressions];\r\n\r\n  faceExpressionsArray.forEach((e) => {\r\n    // eslint-disable-next-line no-nested-ternary\r\n    const expr = e instanceof FaceExpressions\r\n      ? e\r\n      : (isWithFaceExpressions(e) ? e.expressions : undefined);\r\n    if (!expr) {\r\n      throw new Error('drawFaceExpressions - expected faceExpressions to be FaceExpressions | WithFaceExpressions<{}> or array thereof');\r\n    }\r\n\r\n    const sorted = expr.asSortedArray();\r\n    const resultsToDisplay = sorted.filter((exprLocal) => exprLocal.probability > minConfidence);\r\n\r\n    const anchor = isWithFaceDetection(e)\r\n      ? e.detection.box.bottomLeft\r\n      : (textFieldAnchor || new Point(0, 0));\r\n\r\n    const drawTextField = new DrawTextField(\r\n      resultsToDisplay.map((exprLocal) => `${exprLocal.expression} (${round(exprLocal.probability)})`),\r\n      anchor,\r\n    );\r\n    drawTextField.draw(canvasArg);\r\n  });\r\n}\r\n", "import { FaceDetection } from '../classes/FaceDetection';\r\nimport { FaceLandmarks } from '../classes/FaceLandmarks';\r\nimport { FaceLandmarks68 } from '../classes/FaceLandmarks68';\r\nimport { isWithFaceDetection, WithFaceDetection } from './WithFaceDetection';\r\n\r\nexport type WithFaceLandmarks<\r\n  TSource extends WithFaceDetection<{}>,\r\n  TFaceLandmarks extends FaceLandmarks = FaceLandmarks68 > = TSource & {\r\n    landmarks: TFaceLandmarks\r\n    unshiftedLandmarks: TFaceLandmarks\r\n    alignedRect: FaceDetection\r\n  }\r\n\r\nexport function isWithFaceLandmarks(obj: any): obj is WithFaceLandmarks<WithFaceDetection<{}>, FaceLandmarks> {\r\n  return isWithFaceDetection(obj)\r\n    // eslint-disable-next-line dot-notation\r\n    && obj['landmarks'] instanceof FaceLandmarks\r\n    // eslint-disable-next-line dot-notation\r\n    && obj['unshiftedLandmarks'] instanceof FaceLandmarks\r\n    // eslint-disable-next-line dot-notation\r\n    && obj['alignedRect'] instanceof FaceDetection;\r\n}\r\n\r\nexport function extendWithFaceLandmarks<\r\n  TSource extends WithFaceDetection<{}>,\r\n  TFaceLandmarks extends FaceLandmarks = FaceLandmarks68 >(sourceObj: TSource, unshiftedLandmarks: TFaceLandmarks): WithFaceLandmarks<TSource, TFaceLandmarks> {\r\n  const { box: shift } = sourceObj.detection;\r\n  const landmarks = unshiftedLandmarks.shiftBy<TFaceLandmarks>(shift.x, shift.y);\r\n\r\n  const rect = landmarks.align();\r\n  const { imageDims } = sourceObj.detection;\r\n  const alignedRect = new FaceDetection(sourceObj.detection.score, rect.rescale(imageDims.reverse()), imageDims);\r\n\r\n  const extension = {\r\n    landmarks,\r\n    unshiftedLandmarks,\r\n    alignedRect,\r\n  };\r\n\r\n  return { ...sourceObj, ...extension };\r\n}\r\n", "/* eslint-disable max-classes-per-file */\r\nimport { IPoint } from '../classes/index';\r\nimport { FaceLandmarks } from '../classes/FaceLandmarks';\r\nimport { FaceLandmarks68 } from '../classes/FaceLandmarks68';\r\nimport { getContext2dOrThrow } from '../dom/getContext2dOrThrow';\r\nimport { WithFaceDetection } from '../factories/WithFaceDetection';\r\nimport { isWithFaceLandmarks, WithFaceLandmarks } from '../factories/WithFaceLandmarks';\r\nimport { drawContour } from './drawContour';\r\n\r\nexport interface IDrawFaceLandmarksOptions {\r\n  drawLines?: boolean\r\n  drawPoints?: boolean\r\n  lineWidth?: number\r\n  pointSize?: number\r\n  lineColor?: string\r\n  pointColor?: string\r\n}\r\n\r\nexport class DrawFaceLandmarksOptions {\r\n  public drawLines: boolean\r\n\r\n  public drawPoints: boolean\r\n\r\n  public lineWidth: number\r\n\r\n  public pointSize: number\r\n\r\n  public lineColor: string\r\n\r\n  public pointColor: string\r\n\r\n  constructor(options: IDrawFaceLandmarksOptions = {}) {\r\n    const {\r\n      drawLines = true, drawPoints = true, lineWidth, lineColor, pointSize, pointColor,\r\n    } = options;\r\n    this.drawLines = drawLines;\r\n    this.drawPoints = drawPoints;\r\n    this.lineWidth = lineWidth || 1;\r\n    this.pointSize = pointSize || 2;\r\n    this.lineColor = lineColor || 'rgba(0, 255, 255, 1)';\r\n    this.pointColor = pointColor || 'rgba(255, 0, 255, 1)';\r\n  }\r\n}\r\n\r\nexport class DrawFaceLandmarks {\r\n  public faceLandmarks: FaceLandmarks\r\n\r\n  public options: DrawFaceLandmarksOptions\r\n\r\n  constructor(\r\n    faceLandmarks: FaceLandmarks,\r\n    options: IDrawFaceLandmarksOptions = {},\r\n  ) {\r\n    this.faceLandmarks = faceLandmarks;\r\n    this.options = new DrawFaceLandmarksOptions(options);\r\n  }\r\n\r\n  draw(canvasArg: string | HTMLCanvasElement | CanvasRenderingContext2D) {\r\n    const ctx = getContext2dOrThrow(canvasArg);\r\n\r\n    const {\r\n      drawLines, drawPoints, lineWidth, lineColor, pointSize, pointColor,\r\n    } = this.options;\r\n\r\n    if (drawLines && this.faceLandmarks instanceof FaceLandmarks68) {\r\n      ctx.strokeStyle = lineColor;\r\n      ctx.lineWidth = lineWidth;\r\n      drawContour(ctx, this.faceLandmarks.getJawOutline());\r\n      drawContour(ctx, this.faceLandmarks.getLeftEyeBrow());\r\n      drawContour(ctx, this.faceLandmarks.getRightEyeBrow());\r\n      drawContour(ctx, this.faceLandmarks.getNose());\r\n      drawContour(ctx, this.faceLandmarks.getLeftEye(), true);\r\n      drawContour(ctx, this.faceLandmarks.getRightEye(), true);\r\n      drawContour(ctx, this.faceLandmarks.getMouth(), true);\r\n    }\r\n\r\n    if (drawPoints) {\r\n      ctx.strokeStyle = pointColor;\r\n      ctx.fillStyle = pointColor;\r\n\r\n      const drawPoint = (pt: IPoint) => {\r\n        ctx.beginPath();\r\n        ctx.arc(pt.x, pt.y, pointSize, 0, 2 * Math.PI);\r\n        ctx.fill();\r\n      };\r\n      this.faceLandmarks.positions.forEach(drawPoint);\r\n    }\r\n  }\r\n}\r\n\r\nexport type DrawFaceLandmarksInput = FaceLandmarks | WithFaceLandmarks<WithFaceDetection<{}>>\r\n\r\nexport function drawFaceLandmarks(\r\n  canvasArg: string | HTMLCanvasElement,\r\n  faceLandmarks: DrawFaceLandmarksInput | Array<DrawFaceLandmarksInput>,\r\n) {\r\n  const faceLandmarksArray = Array.isArray(faceLandmarks) ? faceLandmarks : [faceLandmarks];\r\n  faceLandmarksArray.forEach((f) => {\r\n    // eslint-disable-next-line no-nested-ternary\r\n    const landmarks = f instanceof FaceLandmarks\r\n      ? f\r\n      : (isWithFaceLandmarks(f) ? f.landmarks : undefined);\r\n    if (!landmarks) {\r\n      throw new Error('drawFaceLandmarks - expected faceExpressions to be FaceLandmarks | WithFaceLandmarks<WithFaceDetection<{}>> or array thereof');\r\n    }\r\n\r\n    new DrawFaceLandmarks(landmarks).draw(canvasArg);\r\n  });\r\n}\r\n", "import * as tf from '../../dist/tfjs.esm';\r\n\r\nimport { fullyConnectedLayer } from '../common/fullyConnectedLayer';\r\nimport { seperateWeightMaps } from '../faceProcessor/util';\r\nimport { TinyXception } from '../xception/TinyXception';\r\nimport { extractParams } from './extractParams';\r\nimport { extractParamsFromWeightMap } from './extractParamsFromWeightMap';\r\nimport {\r\n  AgeAndGenderPrediction, Gender, NetOutput, NetParams,\r\n} from './types';\r\nimport { NeuralNetwork } from '../NeuralNetwork';\r\nimport { NetInput, TNetInput, toNetInput } from '../dom/index';\r\n\r\nexport class AgeGenderNet extends NeuralNetwork<NetParams> {\r\n  private _faceFeatureExtractor: TinyXception\r\n\r\n  constructor(faceFeatureExtractor: TinyXception = new TinyXception(2)) {\r\n    super('AgeGenderNet');\r\n    this._faceFeatureExtractor = faceFeatureExtractor;\r\n  }\r\n\r\n  public get faceFeatureExtractor(): TinyXception {\r\n    return this._faceFeatureExtractor;\r\n  }\r\n\r\n  public runNet(input: NetInput | tf.Tensor4D): NetOutput {\r\n    const { params } = this;\r\n\r\n    if (!params) {\r\n      throw new Error(`${this._name} - load model before inference`);\r\n    }\r\n\r\n    return tf.tidy(() => {\r\n      const bottleneckFeatures = input instanceof NetInput\r\n        ? this.faceFeatureExtractor.forwardInput(input)\r\n        : input;\r\n\r\n      const pooled = tf.avgPool(bottleneckFeatures, [7, 7], [2, 2], 'valid').as2D(bottleneckFeatures.shape[0], -1);\r\n      const age = fullyConnectedLayer(pooled, params.fc.age).as1D();\r\n      const gender = fullyConnectedLayer(pooled, params.fc.gender);\r\n      return { age, gender };\r\n    });\r\n  }\r\n\r\n  public forwardInput(input: NetInput | tf.Tensor4D): NetOutput {\r\n    return tf.tidy(() => {\r\n      const { age, gender } = this.runNet(input);\r\n      return { age, gender: tf.softmax(gender) };\r\n    });\r\n  }\r\n\r\n  public async forward(input: TNetInput): Promise<NetOutput> {\r\n    return this.forwardInput(await toNetInput(input));\r\n  }\r\n\r\n  public async predictAgeAndGender(input: TNetInput): Promise<AgeAndGenderPrediction | AgeAndGenderPrediction[]> {\r\n    const netInput = await toNetInput(input);\r\n    const out = await this.forwardInput(netInput);\r\n\r\n    const ages = tf.unstack(out.age);\r\n    const genders = tf.unstack(out.gender);\r\n    const ageAndGenderTensors = ages.map((ageTensor, i) => ({\r\n      ageTensor,\r\n      genderTensor: genders[i],\r\n    }));\r\n\r\n    const predictionsByBatch = await Promise.all(\r\n      ageAndGenderTensors.map(async ({ ageTensor, genderTensor }) => {\r\n        const age = (await ageTensor.data())[0];\r\n        const probMale = (await genderTensor.data())[0];\r\n        const isMale = probMale > 0.5;\r\n        const gender = isMale ? Gender.MALE : Gender.FEMALE;\r\n        const genderProbability = isMale ? probMale : (1 - probMale);\r\n\r\n        ageTensor.dispose();\r\n        genderTensor.dispose();\r\n        return { age, gender, genderProbability };\r\n      }),\r\n    );\r\n    out.age.dispose();\r\n    out.gender.dispose();\r\n\r\n    return netInput.isBatchInput ? predictionsByBatch as AgeAndGenderPrediction[] : predictionsByBatch[0] as AgeAndGenderPrediction;\r\n  }\r\n\r\n  protected getDefaultModelName(): string {\r\n    return 'age_gender_model';\r\n  }\r\n\r\n  public dispose(throwOnRedispose: boolean = true) {\r\n    this.faceFeatureExtractor.dispose(throwOnRedispose);\r\n    super.dispose(throwOnRedispose);\r\n  }\r\n\r\n  public loadClassifierParams(weights: Float32Array) {\r\n    const { params, paramMappings } = this.extractClassifierParams(weights);\r\n    this._params = params;\r\n    this._paramMappings = paramMappings;\r\n  }\r\n\r\n  public extractClassifierParams(weights: Float32Array) {\r\n    return extractParams(weights);\r\n  }\r\n\r\n  protected extractParamsFromWeightMap(weightMap: tf.NamedTensorMap) {\r\n    const { featureExtractorMap, classifierMap } = seperateWeightMaps(weightMap);\r\n\r\n    this.faceFeatureExtractor.loadFromWeightMap(featureExtractorMap);\r\n\r\n    return extractParamsFromWeightMap(classifierMap);\r\n  }\r\n\r\n  protected extractParams(weights: Float32Array) {\r\n    const classifierWeightSize = (512 * 1 + 1) + (512 * 2 + 2);\r\n\r\n    const featureExtractorWeights = weights.slice(0, weights.length - classifierWeightSize);\r\n    const classifierWeights = weights.slice(weights.length - classifierWeightSize);\r\n\r\n    this.faceFeatureExtractor.extractWeights(featureExtractorWeights);\r\n    return this.extractClassifierParams(classifierWeights);\r\n  }\r\n}\r\n", "import * as tf from '../../dist/tfjs.esm';\r\n\r\nimport { ConvParams, depthwiseSeparableConv } from '../common/index';\r\nimport { NetInput, TNetInput, toNetInput } from '../dom/index';\r\nimport { NeuralNetwork } from '../NeuralNetwork';\r\nimport { normalize } from '../ops/index';\r\nimport { range } from '../utils/index';\r\nimport { extractParams } from './extractParams';\r\nimport { extractParamsFromWeightMap } from './extractParamsFromWeightMap';\r\nimport { MainBlockParams, ReductionBlockParams, TinyXceptionParams } from './types';\r\n\r\nfunction conv(x: tf.Tensor4D, params: ConvParams, stride: [number, number]): tf.Tensor4D {\r\n  return tf.add(tf.conv2d(x, params.filters, stride, 'same'), params.bias);\r\n}\r\n\r\nfunction reductionBlock(x: tf.Tensor4D, params: ReductionBlockParams, isActivateInput: boolean = true): tf.Tensor4D {\r\n  let out = isActivateInput ? tf.relu(x) : x;\r\n  out = depthwiseSeparableConv(out, params.separable_conv0, [1, 1]);\r\n  out = depthwiseSeparableConv(tf.relu(out), params.separable_conv1, [1, 1]);\r\n  out = tf.maxPool(out, [3, 3], [2, 2], 'same');\r\n  out = tf.add(out, conv(x, params.expansion_conv, [2, 2]));\r\n  return out;\r\n}\r\n\r\nfunction mainBlock(x: tf.Tensor4D, params: MainBlockParams): tf.Tensor4D {\r\n  let out = depthwiseSeparableConv(tf.relu(x), params.separable_conv0, [1, 1]);\r\n  out = depthwiseSeparableConv(tf.relu(out), params.separable_conv1, [1, 1]);\r\n  out = depthwiseSeparableConv(tf.relu(out), params.separable_conv2, [1, 1]);\r\n  out = tf.add(out, x);\r\n  return out;\r\n}\r\n\r\nexport class TinyXception extends NeuralNetwork<TinyXceptionParams> {\r\n  private _numMainBlocks: number\r\n\r\n  constructor(numMainBlocks: number) {\r\n    super('TinyXception');\r\n    this._numMainBlocks = numMainBlocks;\r\n  }\r\n\r\n  public forwardInput(input: NetInput): tf.Tensor4D {\r\n    const { params } = this;\r\n    if (!params) {\r\n      throw new Error('TinyXception - load model before inference');\r\n    }\r\n    return tf.tidy(() => {\r\n      const batchTensor = tf.cast(input.toBatchTensor(112, true), 'float32');\r\n      const meanRgb = [122.782, 117.001, 104.298];\r\n      const normalized = normalize(batchTensor, meanRgb).div(tf.scalar(256)) as tf.Tensor4D;\r\n      let out = tf.relu(conv(normalized, params.entry_flow.conv_in, [2, 2]));\r\n      out = reductionBlock(out, params.entry_flow.reduction_block_0, false);\r\n      out = reductionBlock(out, params.entry_flow.reduction_block_1);\r\n      range(this._numMainBlocks, 0, 1).forEach((idx) => {\r\n        out = mainBlock(out, params.middle_flow[`main_block_${idx}`]);\r\n      });\r\n      out = reductionBlock(out, params.exit_flow.reduction_block);\r\n      out = tf.relu(depthwiseSeparableConv(out, params.exit_flow.separable_conv, [1, 1]));\r\n      return out;\r\n    });\r\n  }\r\n\r\n  public async forward(input: TNetInput): Promise<tf.Tensor4D> {\r\n    return this.forwardInput(await toNetInput(input));\r\n  }\r\n\r\n  protected getDefaultModelName(): string {\r\n    return 'tiny_xception_model';\r\n  }\r\n\r\n  protected extractParamsFromWeightMap(weightMap: tf.NamedTensorMap) {\r\n    return extractParamsFromWeightMap(weightMap, this._numMainBlocks);\r\n  }\r\n\r\n  protected extractParams(weights: Float32Array) {\r\n    return extractParams(weights, this._numMainBlocks);\r\n  }\r\n}\r\n", "import { extractConvParamsFactory, extractSeparableConvParamsFactory, extractWeightsFactory } from '../common/index';\r\nimport { ExtractWeightsFunction, ParamMapping } from '../common/types';\r\nimport { range } from '../utils/index';\r\nimport { MainBlockParams, ReductionBlockParams, TinyXceptionParams } from './types';\r\n\r\nfunction extractorsFactory(extractWeights: ExtractWeightsFunction, paramMappings: ParamMapping[]) {\r\n  const extractConvParams = extractConvParamsFactory(extractWeights, paramMappings);\r\n  const extractSeparableConvParams = extractSeparableConvParamsFactory(extractWeights, paramMappings);\r\n\r\n  function extractReductionBlockParams(channelsIn: number, channelsOut: number, mappedPrefix: string): ReductionBlockParams {\r\n    const separable_conv0 = extractSeparableConvParams(channelsIn, channelsOut, `${mappedPrefix}/separable_conv0`);\r\n    const separable_conv1 = extractSeparableConvParams(channelsOut, channelsOut, `${mappedPrefix}/separable_conv1`);\r\n    const expansion_conv = extractConvParams(channelsIn, channelsOut, 1, `${mappedPrefix}/expansion_conv`);\r\n\r\n    return { separable_conv0, separable_conv1, expansion_conv };\r\n  }\r\n\r\n  function extractMainBlockParams(channels: number, mappedPrefix: string): MainBlockParams {\r\n    const separable_conv0 = extractSeparableConvParams(channels, channels, `${mappedPrefix}/separable_conv0`);\r\n    const separable_conv1 = extractSeparableConvParams(channels, channels, `${mappedPrefix}/separable_conv1`);\r\n    const separable_conv2 = extractSeparableConvParams(channels, channels, `${mappedPrefix}/separable_conv2`);\r\n\r\n    return { separable_conv0, separable_conv1, separable_conv2 };\r\n  }\r\n\r\n  return {\r\n    extractConvParams,\r\n    extractSeparableConvParams,\r\n    extractReductionBlockParams,\r\n    extractMainBlockParams,\r\n  };\r\n}\r\n\r\nexport function extractParams(weights: Float32Array, numMainBlocks: number): { params: TinyXceptionParams, paramMappings: ParamMapping[] } {\r\n  const paramMappings: ParamMapping[] = [];\r\n\r\n  const {\r\n    extractWeights,\r\n    getRemainingWeights,\r\n  } = extractWeightsFactory(weights);\r\n\r\n  const {\r\n    extractConvParams,\r\n    extractSeparableConvParams,\r\n    extractReductionBlockParams,\r\n    extractMainBlockParams,\r\n  } = extractorsFactory(extractWeights, paramMappings);\r\n\r\n  const entry_flow_conv_in = extractConvParams(3, 32, 3, 'entry_flow/conv_in');\r\n  const entry_flow_reduction_block_0 = extractReductionBlockParams(32, 64, 'entry_flow/reduction_block_0');\r\n  const entry_flow_reduction_block_1 = extractReductionBlockParams(64, 128, 'entry_flow/reduction_block_1');\r\n\r\n  const entry_flow = {\r\n    conv_in: entry_flow_conv_in,\r\n    reduction_block_0: entry_flow_reduction_block_0,\r\n    reduction_block_1: entry_flow_reduction_block_1,\r\n  };\r\n\r\n  const middle_flow = {};\r\n  range(numMainBlocks, 0, 1).forEach((idx) => {\r\n    middle_flow[`main_block_${idx}`] = extractMainBlockParams(128, `middle_flow/main_block_${idx}`);\r\n  });\r\n\r\n  const exit_flow_reduction_block = extractReductionBlockParams(128, 256, 'exit_flow/reduction_block');\r\n  const exit_flow_separable_conv = extractSeparableConvParams(256, 512, 'exit_flow/separable_conv');\r\n\r\n  const exit_flow = {\r\n    reduction_block: exit_flow_reduction_block,\r\n    separable_conv: exit_flow_separable_conv,\r\n  };\r\n\r\n  if (getRemainingWeights().length !== 0) {\r\n    throw new Error(`weights remaing after extract: ${getRemainingWeights().length}`);\r\n  }\r\n\r\n  return {\r\n    paramMappings,\r\n    params: { entry_flow, middle_flow, exit_flow },\r\n  };\r\n}\r\n", "import * as tf from '../../dist/tfjs.esm';\r\n\r\nimport {\r\n  disposeUnusedWeightTensors,\r\n  extractWeightEntryFactory,\r\n  loadSeparableConvParamsFactory,\r\n  ParamMapping,\r\n} from '../common/index';\r\nimport { loadConvParamsFactory } from '../common/loadConvParamsFactory';\r\nimport { range } from '../utils/index';\r\nimport { MainBlockParams, ReductionBlockParams, TinyXceptionParams } from './types';\r\n\r\nfunction loadParamsFactory(weightMap: any, paramMappings: ParamMapping[]) {\r\n  const extractWeightEntry = extractWeightEntryFactory(weightMap, paramMappings);\r\n\r\n  const extractConvParams = loadConvParamsFactory(extractWeightEntry);\r\n  const extractSeparableConvParams = loadSeparableConvParamsFactory(extractWeightEntry);\r\n\r\n  function extractReductionBlockParams(mappedPrefix: string): ReductionBlockParams {\r\n    const separable_conv0 = extractSeparableConvParams(`${mappedPrefix}/separable_conv0`);\r\n    const separable_conv1 = extractSeparableConvParams(`${mappedPrefix}/separable_conv1`);\r\n    const expansion_conv = extractConvParams(`${mappedPrefix}/expansion_conv`);\r\n\r\n    return { separable_conv0, separable_conv1, expansion_conv };\r\n  }\r\n\r\n  function extractMainBlockParams(mappedPrefix: string): MainBlockParams {\r\n    const separable_conv0 = extractSeparableConvParams(`${mappedPrefix}/separable_conv0`);\r\n    const separable_conv1 = extractSeparableConvParams(`${mappedPrefix}/separable_conv1`);\r\n    const separable_conv2 = extractSeparableConvParams(`${mappedPrefix}/separable_conv2`);\r\n\r\n    return { separable_conv0, separable_conv1, separable_conv2 };\r\n  }\r\n\r\n  return {\r\n    extractConvParams,\r\n    extractSeparableConvParams,\r\n    extractReductionBlockParams,\r\n    extractMainBlockParams,\r\n  };\r\n}\r\n\r\nexport function extractParamsFromWeightMap(\r\n  weightMap: tf.NamedTensorMap,\r\n  numMainBlocks: number,\r\n): { params: TinyXceptionParams, paramMappings: ParamMapping[] } {\r\n  const paramMappings: ParamMapping[] = [];\r\n\r\n  const {\r\n    extractConvParams,\r\n    extractSeparableConvParams,\r\n    extractReductionBlockParams,\r\n    extractMainBlockParams,\r\n  } = loadParamsFactory(weightMap, paramMappings);\r\n\r\n  const entry_flow_conv_in = extractConvParams('entry_flow/conv_in');\r\n  const entry_flow_reduction_block_0 = extractReductionBlockParams('entry_flow/reduction_block_0');\r\n  const entry_flow_reduction_block_1 = extractReductionBlockParams('entry_flow/reduction_block_1');\r\n\r\n  const entry_flow = {\r\n    conv_in: entry_flow_conv_in,\r\n    reduction_block_0: entry_flow_reduction_block_0,\r\n    reduction_block_1: entry_flow_reduction_block_1,\r\n  };\r\n\r\n  const middle_flow = {};\r\n  range(numMainBlocks, 0, 1).forEach((idx) => {\r\n    middle_flow[`main_block_${idx}`] = extractMainBlockParams(`middle_flow/main_block_${idx}`);\r\n  });\r\n\r\n  const exit_flow_reduction_block = extractReductionBlockParams('exit_flow/reduction_block');\r\n  const exit_flow_separable_conv = extractSeparableConvParams('exit_flow/separable_conv');\r\n\r\n  const exit_flow = {\r\n    reduction_block: exit_flow_reduction_block,\r\n    separable_conv: exit_flow_separable_conv,\r\n  };\r\n\r\n  disposeUnusedWeightTensors(weightMap, paramMappings);\r\n\r\n  return { params: { entry_flow, middle_flow, exit_flow }, paramMappings };\r\n}\r\n", "import { extractFCParamsFactory, extractWeightsFactory, ParamMapping } from '../common/index';\r\nimport { NetParams } from './types';\r\n\r\nexport function extractParams(weights: Float32Array): { params: NetParams, paramMappings: ParamMapping[] } {\r\n  const paramMappings: ParamMapping[] = [];\r\n\r\n  const {\r\n    extractWeights,\r\n    getRemainingWeights,\r\n  } = extractWeightsFactory(weights);\r\n\r\n  const extractFCParams = extractFCParamsFactory(extractWeights, paramMappings);\r\n\r\n  const age = extractFCParams(512, 1, 'fc/age');\r\n  const gender = extractFCParams(512, 2, 'fc/gender');\r\n\r\n  if (getRemainingWeights().length !== 0) {\r\n    throw new Error(`weights remaing after extract: ${getRemainingWeights().length}`);\r\n  }\r\n\r\n  return {\r\n    paramMappings,\r\n    params: { fc: { age, gender } },\r\n  };\r\n}\r\n", "import * as tf from '../../dist/tfjs.esm';\r\n\r\nimport {\r\n  disposeUnusedWeightTensors, extractWeightEntryFactory, FCParams, ParamMapping,\r\n} from '../common/index';\r\nimport { NetParams } from './types';\r\n\r\nexport function extractParamsFromWeightMap(\r\n  weightMap: tf.NamedTensorMap,\r\n): { params: NetParams, paramMappings: ParamMapping[] } {\r\n  const paramMappings: ParamMapping[] = [];\r\n\r\n  const extractWeightEntry = extractWeightEntryFactory(weightMap, paramMappings);\r\n\r\n  function extractFcParams(prefix: string): FCParams {\r\n    const weights = extractWeightEntry(`${prefix}/weights`, 2);\r\n    const bias = extractWeightEntry(`${prefix}/bias`, 1);\r\n    return { weights, bias };\r\n  }\r\n\r\n  const params = {\r\n    fc: {\r\n      age: extractFcParams('fc/age'),\r\n      gender: extractFcParams('fc/gender'),\r\n    },\r\n  };\r\n\r\n  disposeUnusedWeightTensors(weightMap, paramMappings);\r\n\r\n  return { params, paramMappings };\r\n}\r\n", "import * as tf from '../../dist/tfjs.esm';\r\n\r\nimport { FCParams } from '../common/index';\r\n\r\n// eslint-disable-next-line no-shadow\r\nexport enum Gender {\r\n  // eslint-disable-next-line no-unused-vars\r\n  FEMALE = 'female',\r\n  // eslint-disable-next-line no-unused-vars\r\n  MALE = 'male'\r\n}\r\n\r\nexport type AgeAndGenderPrediction = {\r\n  age: number\r\n  gender: Gender\r\n  genderProbability: number\r\n}\r\n\r\nexport type NetOutput = { age: tf.Tensor1D, gender: tf.Tensor2D }\r\n\r\nexport type NetParams = {\r\n  fc: {\r\n    age: FCParams\r\n    gender: FCParams\r\n  }\r\n}\r\n", "import * as tf from '../../dist/tfjs.esm';\r\n\r\nimport { IDimensions, Point } from '../classes/index';\r\nimport { FaceLandmarks68 } from '../classes/FaceLandmarks68';\r\nimport { NetInput, TNetInput, toNetInput } from '../dom/index';\r\nimport { FaceFeatureExtractorParams, TinyFaceFeatureExtractorParams } from '../faceFeatureExtractor/types';\r\nimport { FaceProcessor } from '../faceProcessor/FaceProcessor';\r\nimport { isEven } from '../utils/index';\r\n\r\nexport abstract class FaceLandmark68NetBase<\r\n  TExtractorParams extends FaceFeatureExtractorParams | TinyFaceFeatureExtractorParams\r\n>\r\n  extends FaceProcessor<TExtractorParams> {\r\n  public postProcess(output: tf.Tensor2D, inputSize: number, originalDimensions: IDimensions[]): tf.Tensor2D {\r\n    const inputDimensions = originalDimensions.map(({ width, height }) => {\r\n      const scale = inputSize / Math.max(height, width);\r\n      return {\r\n        width: width * scale,\r\n        height: height * scale,\r\n      };\r\n    });\r\n\r\n    const batchSize = inputDimensions.length;\r\n\r\n    return tf.tidy(() => {\r\n      const createInterleavedTensor = (fillX: number, fillY: number) => tf.stack([tf.fill([68], fillX, 'float32'), tf.fill([68], fillY, 'float32')], 1).as2D(1, 136).as1D();\r\n\r\n      // eslint-disable-next-line no-unused-vars\r\n      const getPadding = (batchIdx: number, cond: (w: number, h: number) => boolean): number => {\r\n        const { width, height } = inputDimensions[batchIdx];\r\n        return cond(width, height) ? Math.abs(width - height) / 2 : 0;\r\n      };\r\n\r\n      const getPaddingX = (batchIdx: number) => getPadding(batchIdx, (w, h) => w < h);\r\n      const getPaddingY = (batchIdx: number) => getPadding(batchIdx, (w, h) => h < w);\r\n\r\n      const landmarkTensors = output\r\n        .mul(tf.fill([batchSize, 136], inputSize, 'float32'))\r\n        .sub(tf.stack(Array.from(Array(batchSize), (_, batchIdx) => createInterleavedTensor(\r\n          getPaddingX(batchIdx),\r\n          getPaddingY(batchIdx),\r\n        ))))\r\n        .div(tf.stack(Array.from(Array(batchSize), (_, batchIdx) => createInterleavedTensor(\r\n          inputDimensions[batchIdx].width,\r\n          inputDimensions[batchIdx].height,\r\n        ))));\r\n\r\n      return landmarkTensors as tf.Tensor2D;\r\n    });\r\n  }\r\n\r\n  public forwardInput(input: NetInput): tf.Tensor2D {\r\n    return tf.tidy(() => {\r\n      const out = this.runNet(input);\r\n      return this.postProcess(\r\n        out,\r\n        input.inputSize as number,\r\n        input.inputDimensions.map(([height, width]) => ({ height, width })),\r\n      );\r\n    });\r\n  }\r\n\r\n  public async forward(input: TNetInput): Promise<tf.Tensor2D> {\r\n    return this.forwardInput(await toNetInput(input));\r\n  }\r\n\r\n  public async detectLandmarks(input: TNetInput): Promise<FaceLandmarks68 | FaceLandmarks68[]> {\r\n    const netInput = await toNetInput(input);\r\n    const landmarkTensors = tf.tidy(\r\n      () => tf.unstack(this.forwardInput(netInput)),\r\n    );\r\n\r\n    const landmarksForBatch = await Promise.all(landmarkTensors.map(\r\n      async (landmarkTensor, batchIdx) => {\r\n        const landmarksArray = Array.from(await landmarkTensor.data());\r\n        const xCoords = landmarksArray.filter((_, i) => isEven(i));\r\n        const yCoords = landmarksArray.filter((_, i) => !isEven(i));\r\n\r\n        return new FaceLandmarks68(\r\n          Array(68).fill(0).map((_, i) => new Point(xCoords[i] as number, yCoords[i] as number)),\r\n          {\r\n            height: netInput.getInputHeight(batchIdx),\r\n            width: netInput.getInputWidth(batchIdx),\r\n          },\r\n        );\r\n      },\r\n    ));\r\n\r\n    landmarkTensors.forEach((t) => t.dispose());\r\n\r\n    return netInput.isBatchInput ? landmarksForBatch as FaceLandmarks68[] : landmarksForBatch[0] as FaceLandmarks68;\r\n  }\r\n\r\n  protected getClassifierChannelsOut(): number {\r\n    return 136;\r\n  }\r\n}\r\n", "import { FaceFeatureExtractor } from '../faceFeatureExtractor/FaceFeatureExtractor';\r\nimport { FaceFeatureExtractorParams } from '../faceFeatureExtractor/types';\r\nimport { FaceLandmark68NetBase } from './FaceLandmark68NetBase';\r\n\r\nexport class FaceLandmark68Net extends FaceLandmark68NetBase<FaceFeatureExtractorParams> {\r\n  constructor(faceFeatureExtractor: FaceFeatureExtractor = new FaceFeatureExtractor()) {\r\n    super('FaceLandmark68Net', faceFeatureExtractor);\r\n  }\r\n\r\n  protected getDefaultModelName(): string {\r\n    return 'face_landmark_68_model';\r\n  }\r\n\r\n  protected getClassifierChannelsIn(): number {\r\n    return 256;\r\n  }\r\n}\r\n", "import * as tf from '../../dist/tfjs.esm';\r\n\r\nimport { NetInput, TNetInput, toNetInput } from '../dom/index';\r\nimport { NeuralNetwork } from '../NeuralNetwork';\r\nimport { normalize } from '../ops/index';\r\nimport { denseBlock3 } from './denseBlock';\r\nimport { extractParamsFromWeightMapTiny } from './extractParamsFromWeightMapTiny';\r\nimport { extractParamsTiny } from './extractParamsTiny';\r\nimport { IFaceFeatureExtractor, TinyFaceFeatureExtractorParams } from './types';\r\n\r\nexport class TinyFaceFeatureExtractor extends NeuralNetwork<TinyFaceFeatureExtractorParams> implements IFaceFeatureExtractor<TinyFaceFeatureExtractorParams> {\r\n  constructor() {\r\n    super('TinyFaceFeatureExtractor');\r\n  }\r\n\r\n  public forwardInput(input: NetInput): tf.Tensor4D {\r\n    const { params } = this;\r\n\r\n    if (!params) {\r\n      throw new Error('TinyFaceFeatureExtractor - load model before inference');\r\n    }\r\n\r\n    return tf.tidy(() => {\r\n      const batchTensor = tf.cast(input.toBatchTensor(112, true), 'float32');\r\n      const meanRgb = [122.782, 117.001, 104.298];\r\n      const normalized = normalize(batchTensor, meanRgb).div(tf.scalar(255)) as tf.Tensor4D;\r\n\r\n      let out = denseBlock3(normalized, params.dense0, true);\r\n      out = denseBlock3(out, params.dense1);\r\n      out = denseBlock3(out, params.dense2);\r\n      out = tf.avgPool(out, [14, 14], [2, 2], 'valid');\r\n\r\n      return out;\r\n    });\r\n  }\r\n\r\n  public async forward(input: TNetInput): Promise<tf.Tensor4D> {\r\n    return this.forwardInput(await toNetInput(input));\r\n  }\r\n\r\n  protected getDefaultModelName(): string {\r\n    return 'face_feature_extractor_tiny_model';\r\n  }\r\n\r\n  protected extractParamsFromWeightMap(weightMap: tf.NamedTensorMap) {\r\n    return extractParamsFromWeightMapTiny(weightMap);\r\n  }\r\n\r\n  protected extractParams(weights: Float32Array) {\r\n    return extractParamsTiny(weights);\r\n  }\r\n}\r\n", "import * as tf from '../../dist/tfjs.esm';\r\n\r\nimport { disposeUnusedWeightTensors, ParamMapping } from '../common/index';\r\nimport { loadParamsFactory } from './loadParamsFactory';\r\nimport { TinyFaceFeatureExtractorParams } from './types';\r\n\r\nexport function extractParamsFromWeightMapTiny(\r\n  weightMap: tf.NamedTensorMap,\r\n): { params: TinyFaceFeatureExtractorParams, paramMappings: ParamMapping[] } {\r\n  const paramMappings: ParamMapping[] = [];\r\n\r\n  const {\r\n    extractDenseBlock3Params,\r\n  } = loadParamsFactory(weightMap, paramMappings);\r\n\r\n  const params = {\r\n    dense0: extractDenseBlock3Params('dense0', true),\r\n    dense1: extractDenseBlock3Params('dense1'),\r\n    dense2: extractDenseBlock3Params('dense2'),\r\n  };\r\n\r\n  disposeUnusedWeightTensors(weightMap, paramMappings);\r\n\r\n  return { params, paramMappings };\r\n}\r\n", "import { extractWeightsFactory, ParamMapping } from '../common/index';\r\nimport { extractorsFactory } from './extractorsFactory';\r\nimport { TinyFaceFeatureExtractorParams } from './types';\r\n\r\nexport function extractParamsTiny(weights: Float32Array): { params: TinyFaceFeatureExtractorParams, paramMappings: ParamMapping[] } {\r\n  const paramMappings: ParamMapping[] = [];\r\n\r\n  const {\r\n    extractWeights,\r\n    getRemainingWeights,\r\n  } = extractWeightsFactory(weights);\r\n\r\n  const {\r\n    extractDenseBlock3Params,\r\n  } = extractorsFactory(extractWeights, paramMappings);\r\n\r\n  const dense0 = extractDenseBlock3Params(3, 32, 'dense0', true);\r\n  const dense1 = extractDenseBlock3Params(32, 64, 'dense1');\r\n  const dense2 = extractDenseBlock3Params(64, 128, 'dense2');\r\n\r\n  if (getRemainingWeights().length !== 0) {\r\n    throw new Error(`weights remaing after extract: ${getRemainingWeights().length}`);\r\n  }\r\n\r\n  return {\r\n    paramMappings,\r\n    params: { dense0, dense1, dense2 },\r\n  };\r\n}\r\n", "import { TinyFaceFeatureExtractor } from '../faceFeatureExtractor/TinyFaceFeatureExtractor';\r\nimport { TinyFaceFeatureExtractorParams } from '../faceFeatureExtractor/types';\r\nimport { FaceLandmark68NetBase } from './FaceLandmark68NetBase';\r\n\r\nexport class FaceLandmark68TinyNet extends FaceLandmark68NetBase<TinyFaceFeatureExtractorParams> {\r\n  constructor(faceFeatureExtractor: TinyFaceFeatureExtractor = new TinyFaceFeatureExtractor()) {\r\n    super('FaceLandmark68TinyNet', faceFeatureExtractor);\r\n  }\r\n\r\n  protected getDefaultModelName(): string {\r\n    return 'face_landmark_68_tiny_model';\r\n  }\r\n\r\n  protected getClassifierChannelsIn(): number {\r\n    return 128;\r\n  }\r\n}\r\n", "import { FaceLandmark68Net } from './FaceLandmark68Net';\r\n\r\nexport * from './FaceLandmark68Net';\r\nexport * from './FaceLandmark68TinyNet';\r\nexport class FaceLandmarkNet extends FaceLandmark68Net {}\r\n", "import * as tf from '../../dist/tfjs.esm';\r\n\r\nimport { NetInput, TNetInput, toNetInput } from '../dom/index';\r\nimport { NeuralNetwork } from '../NeuralNetwork';\r\nimport { normalize } from '../ops/index';\r\nimport { convDown } from './convLayer';\r\nimport { extractParams } from './extractParams';\r\nimport { extractParamsFromWeightMap } from './extractParamsFromWeightMap';\r\nimport { residual, residualDown } from './residualLayer';\r\nimport { NetParams } from './types';\r\n\r\nexport class FaceRecognitionNet extends NeuralNetwork<NetParams> {\r\n  constructor() {\r\n    super('FaceRecognitionNet');\r\n  }\r\n\r\n  public forwardInput(input: NetInput): tf.Tensor2D {\r\n    const { params } = this;\r\n\r\n    if (!params) {\r\n      throw new Error('FaceRecognitionNet - load model before inference');\r\n    }\r\n\r\n    return tf.tidy(() => {\r\n      const batchTensor = tf.cast(input.toBatchTensor(150, true), 'float32');\r\n\r\n      const meanRgb = [122.782, 117.001, 104.298];\r\n      const normalized = normalize(batchTensor, meanRgb).div(tf.scalar(256)) as tf.Tensor4D;\r\n\r\n      let out = convDown(normalized, params.conv32_down);\r\n      out = tf.maxPool(out, 3, 2, 'valid');\r\n\r\n      out = residual(out, params.conv32_1);\r\n      out = residual(out, params.conv32_2);\r\n      out = residual(out, params.conv32_3);\r\n\r\n      out = residualDown(out, params.conv64_down);\r\n      out = residual(out, params.conv64_1);\r\n      out = residual(out, params.conv64_2);\r\n      out = residual(out, params.conv64_3);\r\n\r\n      out = residualDown(out, params.conv128_down);\r\n      out = residual(out, params.conv128_1);\r\n      out = residual(out, params.conv128_2);\r\n\r\n      out = residualDown(out, params.conv256_down);\r\n      out = residual(out, params.conv256_1);\r\n      out = residual(out, params.conv256_2);\r\n      out = residualDown(out, params.conv256_down_out);\r\n\r\n      const globalAvg = out.mean([1, 2]) as tf.Tensor2D;\r\n      const fullyConnected = tf.matMul(globalAvg, params.fc);\r\n\r\n      return fullyConnected;\r\n    });\r\n  }\r\n\r\n  public async forward(input: TNetInput): Promise<tf.Tensor2D> {\r\n    return this.forwardInput(await toNetInput(input));\r\n  }\r\n\r\n  public async computeFaceDescriptor(input: TNetInput): Promise<Float32Array|Float32Array[]> {\r\n    if (input?.shape?.some((dim) => dim <= 0)) return new Float32Array(128);\r\n    const netInput = await toNetInput(input);\r\n    const faceDescriptorTensors = tf.tidy(\r\n      () => tf.unstack(this.forwardInput(netInput)),\r\n    );\r\n    const faceDescriptorsForBatch = await Promise.all(faceDescriptorTensors.map((t) => t.data())) as Float32Array[];\r\n    faceDescriptorTensors.forEach((t) => t.dispose());\r\n    return netInput.isBatchInput ? faceDescriptorsForBatch : faceDescriptorsForBatch[0];\r\n  }\r\n\r\n  protected getDefaultModelName(): string {\r\n    return 'face_recognition_model';\r\n  }\r\n\r\n  protected extractParamsFromWeightMap(weightMap: tf.NamedTensorMap) {\r\n    return extractParamsFromWeightMap(weightMap);\r\n  }\r\n\r\n  protected extractParams(weights: Float32Array) {\r\n    return extractParams(weights);\r\n  }\r\n}\r\n", "import * as tf from '../../dist/tfjs.esm';\r\n\r\nimport { scale } from './scaleLayer';\r\nimport { ConvLayerParams } from './types';\r\n\r\nfunction convLayer(\r\n  x: tf.Tensor4D,\r\n  params: ConvLayerParams,\r\n  strides: [number, number],\r\n  withRelu: boolean,\r\n  padding: 'valid' | 'same' = 'same',\r\n): tf.Tensor4D {\r\n  const { filters, bias } = params.conv;\r\n\r\n  let out = tf.conv2d(x, filters, strides, padding);\r\n  out = tf.add(out, bias);\r\n  out = scale(out, params.scale);\r\n  return withRelu ? tf.relu(out) : out;\r\n}\r\n\r\nexport function conv(x: tf.Tensor4D, params: ConvLayerParams) {\r\n  return convLayer(x, params, [1, 1], true);\r\n}\r\n\r\nexport function convNoRelu(x: tf.Tensor4D, params: ConvLayerParams) {\r\n  return convLayer(x, params, [1, 1], false);\r\n}\r\n\r\nexport function convDown(x: tf.Tensor4D, params: ConvLayerParams) {\r\n  return convLayer(x, params, [2, 2], true, 'valid');\r\n}\r\n", "import * as tf from '../../dist/tfjs.esm';\r\n\r\nimport { ScaleLayerParams } from './types';\r\n\r\nexport function scale(x: tf.Tensor4D, params: ScaleLayerParams): tf.Tensor4D {\r\n  return tf.add(tf.mul(x, params.weights), params.biases);\r\n}\r\n", "import * as tf from '../../dist/tfjs.esm';\r\n\r\nimport {\r\n  ConvParams, extractWeightsFactory, ExtractWeightsFunction, ParamMapping,\r\n} from '../common/index';\r\nimport { isFloat } from '../utils/index';\r\nimport {\r\n  ConvLayerParams, NetParams, ResidualLayerParams, ScaleLayerParams,\r\n} from './types';\r\n\r\nfunction extractorsFactory(extractWeights: ExtractWeightsFunction, paramMappings: ParamMapping[]) {\r\n  function extractFilterValues(numFilterValues: number, numFilters: number, filterSize: number): tf.Tensor4D {\r\n    const weights = extractWeights(numFilterValues);\r\n    const depth = weights.length / (numFilters * filterSize * filterSize);\r\n\r\n    if (isFloat(depth)) {\r\n      throw new Error(`depth has to be an integer: ${depth}, weights.length: ${weights.length}, numFilters: ${numFilters}, filterSize: ${filterSize}`);\r\n    }\r\n\r\n    return tf.tidy(\r\n      () => tf.transpose(\r\n        tf.tensor4d(weights, [numFilters, depth, filterSize, filterSize]),\r\n        [2, 3, 1, 0],\r\n      ),\r\n    );\r\n  }\r\n\r\n  function extractConvParams(\r\n    numFilterValues: number,\r\n    numFilters: number,\r\n    filterSize: number,\r\n    mappedPrefix: string,\r\n  ): ConvParams {\r\n    const filters = extractFilterValues(numFilterValues, numFilters, filterSize);\r\n    const bias = tf.tensor1d(extractWeights(numFilters));\r\n\r\n    paramMappings.push(\r\n      { paramPath: `${mappedPrefix}/filters` },\r\n      { paramPath: `${mappedPrefix}/bias` },\r\n    );\r\n\r\n    return { filters, bias };\r\n  }\r\n\r\n  function extractScaleLayerParams(numWeights: number, mappedPrefix: string): ScaleLayerParams {\r\n    const weights = tf.tensor1d(extractWeights(numWeights));\r\n    const biases = tf.tensor1d(extractWeights(numWeights));\r\n\r\n    paramMappings.push(\r\n      { paramPath: `${mappedPrefix}/weights` },\r\n      { paramPath: `${mappedPrefix}/biases` },\r\n    );\r\n\r\n    return {\r\n      weights,\r\n      biases,\r\n    };\r\n  }\r\n\r\n  function extractConvLayerParams(\r\n    numFilterValues: number,\r\n    numFilters: number,\r\n    filterSize: number,\r\n    mappedPrefix: string,\r\n  ): ConvLayerParams {\r\n    const conv = extractConvParams(numFilterValues, numFilters, filterSize, `${mappedPrefix}/conv`);\r\n    const scale = extractScaleLayerParams(numFilters, `${mappedPrefix}/scale`);\r\n\r\n    return { conv, scale };\r\n  }\r\n\r\n  function extractResidualLayerParams(\r\n    numFilterValues: number,\r\n    numFilters: number,\r\n    filterSize: number,\r\n    mappedPrefix: string,\r\n    isDown: boolean = false,\r\n  ): ResidualLayerParams {\r\n    const conv1 = extractConvLayerParams((isDown ? 0.5 : 1) * numFilterValues, numFilters, filterSize, `${mappedPrefix}/conv1`);\r\n    const conv2 = extractConvLayerParams(numFilterValues, numFilters, filterSize, `${mappedPrefix}/conv2`);\r\n\r\n    return { conv1, conv2 };\r\n  }\r\n\r\n  return {\r\n    extractConvLayerParams,\r\n    extractResidualLayerParams,\r\n  };\r\n}\r\n\r\nexport function extractParams(weights: Float32Array): { params: NetParams, paramMappings: ParamMapping[] } {\r\n  const {\r\n    extractWeights,\r\n    getRemainingWeights,\r\n  } = extractWeightsFactory(weights);\r\n\r\n  const paramMappings: ParamMapping[] = [];\r\n\r\n  const {\r\n    extractConvLayerParams,\r\n    extractResidualLayerParams,\r\n  } = extractorsFactory(extractWeights, paramMappings);\r\n\r\n  const conv32_down = extractConvLayerParams(4704, 32, 7, 'conv32_down');\r\n  const conv32_1 = extractResidualLayerParams(9216, 32, 3, 'conv32_1');\r\n  const conv32_2 = extractResidualLayerParams(9216, 32, 3, 'conv32_2');\r\n  const conv32_3 = extractResidualLayerParams(9216, 32, 3, 'conv32_3');\r\n\r\n  const conv64_down = extractResidualLayerParams(36864, 64, 3, 'conv64_down', true);\r\n  const conv64_1 = extractResidualLayerParams(36864, 64, 3, 'conv64_1');\r\n  const conv64_2 = extractResidualLayerParams(36864, 64, 3, 'conv64_2');\r\n  const conv64_3 = extractResidualLayerParams(36864, 64, 3, 'conv64_3');\r\n\r\n  const conv128_down = extractResidualLayerParams(147456, 128, 3, 'conv128_down', true);\r\n  const conv128_1 = extractResidualLayerParams(147456, 128, 3, 'conv128_1');\r\n  const conv128_2 = extractResidualLayerParams(147456, 128, 3, 'conv128_2');\r\n\r\n  const conv256_down = extractResidualLayerParams(589824, 256, 3, 'conv256_down', true);\r\n  const conv256_1 = extractResidualLayerParams(589824, 256, 3, 'conv256_1');\r\n  const conv256_2 = extractResidualLayerParams(589824, 256, 3, 'conv256_2');\r\n  const conv256_down_out = extractResidualLayerParams(589824, 256, 3, 'conv256_down_out');\r\n\r\n  const fc = tf.tidy(\r\n    () => tf.transpose(tf.tensor2d(extractWeights(256 * 128), [128, 256]), [1, 0]),\r\n  );\r\n  paramMappings.push({ paramPath: 'fc' });\r\n\r\n  if (getRemainingWeights().length !== 0) {\r\n    throw new Error(`weights remaing after extract: ${getRemainingWeights().length}`);\r\n  }\r\n\r\n  const params = {\r\n    conv32_down,\r\n    conv32_1,\r\n    conv32_2,\r\n    conv32_3,\r\n    conv64_down,\r\n    conv64_1,\r\n    conv64_2,\r\n    conv64_3,\r\n    conv128_down,\r\n    conv128_1,\r\n    conv128_2,\r\n    conv256_down,\r\n    conv256_1,\r\n    conv256_2,\r\n    conv256_down_out,\r\n    fc,\r\n  };\r\n\r\n  return { params, paramMappings };\r\n}\r\n", "import * as tf from '../../dist/tfjs.esm';\r\n\r\nimport { disposeUnusedWeightTensors, extractWeightEntryFactory, ParamMapping } from '../common/index';\r\nimport { isTensor2D } from '../utils/index';\r\nimport { ConvLayerParams, NetParams, ResidualLayerParams, ScaleLayerParams } from './types';\r\n\r\nfunction extractorsFactory(weightMap: any, paramMappings: ParamMapping[]) {\r\n  const extractWeightEntry = extractWeightEntryFactory(weightMap, paramMappings);\r\n\r\n  function extractScaleLayerParams(prefix: string): ScaleLayerParams {\r\n    const weights = extractWeightEntry(`${prefix}/scale/weights`, 1);\r\n    const biases = extractWeightEntry(`${prefix}/scale/biases`, 1);\r\n\r\n    return { weights, biases };\r\n  }\r\n\r\n  function extractConvLayerParams(prefix: string): ConvLayerParams {\r\n    const filters = extractWeightEntry(`${prefix}/conv/filters`, 4);\r\n    const bias = extractWeightEntry(`${prefix}/conv/bias`, 1);\r\n    const scale = extractScaleLayerParams(prefix);\r\n\r\n    return { conv: { filters, bias }, scale };\r\n  }\r\n\r\n  function extractResidualLayerParams(prefix: string): ResidualLayerParams {\r\n    return {\r\n      conv1: extractConvLayerParams(`${prefix}/conv1`),\r\n      conv2: extractConvLayerParams(`${prefix}/conv2`),\r\n    };\r\n  }\r\n\r\n  return {\r\n    extractConvLayerParams,\r\n    extractResidualLayerParams,\r\n  };\r\n}\r\n\r\nexport function extractParamsFromWeightMap(\r\n  weightMap: tf.NamedTensorMap,\r\n): { params: NetParams, paramMappings: ParamMapping[] } {\r\n  const paramMappings: ParamMapping[] = [];\r\n\r\n  const {\r\n    extractConvLayerParams,\r\n    extractResidualLayerParams,\r\n  } = extractorsFactory(weightMap, paramMappings);\r\n\r\n  const conv32_down = extractConvLayerParams('conv32_down');\r\n  const conv32_1 = extractResidualLayerParams('conv32_1');\r\n  const conv32_2 = extractResidualLayerParams('conv32_2');\r\n  const conv32_3 = extractResidualLayerParams('conv32_3');\r\n\r\n  const conv64_down = extractResidualLayerParams('conv64_down');\r\n  const conv64_1 = extractResidualLayerParams('conv64_1');\r\n  const conv64_2 = extractResidualLayerParams('conv64_2');\r\n  const conv64_3 = extractResidualLayerParams('conv64_3');\r\n\r\n  const conv128_down = extractResidualLayerParams('conv128_down');\r\n  const conv128_1 = extractResidualLayerParams('conv128_1');\r\n  const conv128_2 = extractResidualLayerParams('conv128_2');\r\n\r\n  const conv256_down = extractResidualLayerParams('conv256_down');\r\n  const conv256_1 = extractResidualLayerParams('conv256_1');\r\n  const conv256_2 = extractResidualLayerParams('conv256_2');\r\n  const conv256_down_out = extractResidualLayerParams('conv256_down_out');\r\n\r\n  const { fc } = weightMap;\r\n  paramMappings.push({ originalPath: 'fc', paramPath: 'fc' });\r\n\r\n  if (!isTensor2D(fc)) {\r\n    throw new Error(`expected weightMap[fc] to be a Tensor2D, instead have ${fc}`);\r\n  }\r\n\r\n  const params = {\r\n    conv32_down,\r\n    conv32_1,\r\n    conv32_2,\r\n    conv32_3,\r\n    conv64_down,\r\n    conv64_1,\r\n    conv64_2,\r\n    conv64_3,\r\n    conv128_down,\r\n    conv128_1,\r\n    conv128_2,\r\n    conv256_down,\r\n    conv256_1,\r\n    conv256_2,\r\n    conv256_down_out,\r\n    fc,\r\n  };\r\n\r\n  disposeUnusedWeightTensors(weightMap, paramMappings);\r\n\r\n  return { params, paramMappings };\r\n}\r\n", "import * as tf from '../../dist/tfjs.esm';\r\n\r\nimport { conv, convDown, convNoRelu } from './convLayer';\r\nimport { ResidualLayerParams } from './types';\r\n\r\nexport function residual(x: tf.Tensor4D, params: ResidualLayerParams): tf.Tensor4D {\r\n  let out = conv(x, params.conv1);\r\n  out = convNoRelu(out, params.conv2);\r\n  out = tf.add(out, x);\r\n  out = tf.relu(out);\r\n  return out;\r\n}\r\n\r\nexport function residualDown(x: tf.Tensor4D, params: ResidualLayerParams): tf.Tensor4D {\r\n  let out = convDown(x, params.conv1);\r\n  out = convNoRelu(out, params.conv2);\r\n\r\n  let pooled = tf.avgPool(x, 2, 2, 'valid') as tf.Tensor4D;\r\n  const zeros = tf.zeros<tf.Rank.R4>(pooled.shape);\r\n  const isPad = pooled.shape[3] !== out.shape[3];\r\n  const isAdjustShape = pooled.shape[1] !== out.shape[1] || pooled.shape[2] !== out.shape[2];\r\n\r\n  if (isAdjustShape) {\r\n    const padShapeX = [...out.shape] as [number, number, number, number];\r\n    padShapeX[1] = 1;\r\n    const zerosW = tf.zeros<tf.Rank.R4>(padShapeX);\r\n    out = tf.concat([out, zerosW], 1);\r\n\r\n    const padShapeY = [...out.shape] as [number, number, number, number];\r\n    padShapeY[2] = 1;\r\n    const zerosH = tf.zeros<tf.Rank.R4>(padShapeY);\r\n    out = tf.concat([out, zerosH], 2);\r\n  }\r\n\r\n  pooled = isPad ? tf.concat([pooled, zeros], 3) : pooled;\r\n  out = tf.add(pooled, out) as tf.Tensor4D;\r\n\r\n  out = tf.relu(out);\r\n  return out;\r\n}\r\n", "import { FaceRecognitionNet } from './FaceRecognitionNet';\r\n\r\nexport * from './FaceRecognitionNet';\r\n\r\nexport function createFaceRecognitionNet(weights: Float32Array) {\r\n  const net = new FaceRecognitionNet();\r\n  net.extractWeights(weights);\r\n  return net;\r\n}\r\n", "export type WithFaceDescriptor<TSource> = TSource & {\r\n  descriptor: Float32Array\r\n}\r\n\r\nexport function extendWithFaceDescriptor<\r\n  TSource\r\n>(\r\n  sourceObj: TSource,\r\n  descriptor: Float32Array,\r\n): WithFaceDescriptor<TSource> {\r\n  const extension = { descriptor };\r\n  return { ...sourceObj, ...extension };\r\n}\r\n", "export type WithAge<TSource> = TSource & {\r\n  age: number\r\n}\r\n\r\nexport function isWithAge(obj: any): obj is WithAge<{}> {\r\n  return typeof obj.age === 'number';\r\n}\r\n\r\nexport function extendWithAge<\r\n  TSource\r\n>(\r\n  sourceObj: TSource,\r\n  age: number,\r\n): WithAge<TSource> {\r\n  const extension = { age };\r\n  return { ...sourceObj, ...extension };\r\n}\r\n", "import { Gender } from '../ageGenderNet/types';\r\nimport { isValidProbablitiy } from '../utils/index';\r\n\r\nexport type WithGender<TSource> = TSource & {\r\n  gender: Gender\r\n  genderProbability: number\r\n}\r\n\r\nexport function isWithGender(obj: any): obj is WithGender<{}> {\r\n  return (obj.gender === Gender.MALE || obj.gender === Gender.FEMALE)\r\n    && isValidProbablitiy(obj.genderProbability);\r\n}\r\n\r\nexport function extendWithGender<\r\n  TSource\r\n>(\r\n  sourceObj: TSource,\r\n  gender: Gender,\r\n  genderProbability: number,\r\n): WithGender<TSource> {\r\n  const extension = { gender, genderProbability };\r\n  return { ...sourceObj, ...extension };\r\n}\r\n", "import * as tf from '../../dist/tfjs.esm';\r\n\r\nimport { Rect } from '../classes/index';\r\nimport { FaceDetection } from '../classes/FaceDetection';\r\nimport { NetInput, TNetInput, toNetInput } from '../dom/index';\r\nimport { NeuralNetwork } from '../NeuralNetwork';\r\nimport { extractParams } from './extractParams';\r\nimport { extractParamsFromWeightMap } from './extractParamsFromWeightMap';\r\nimport { mobileNetV1 } from './mobileNetV1';\r\nimport { nonMaxSuppression } from './nonMaxSuppression';\r\nimport { outputLayer } from './outputLayer';\r\nimport { predictionLayer } from './predictionLayer';\r\nimport { ISsdMobilenetv1Options, SsdMobilenetv1Options } from './SsdMobilenetv1Options';\r\nimport { NetParams } from './types';\r\n\r\nexport class SsdMobilenetv1 extends NeuralNetwork<NetParams> {\r\n  constructor() {\r\n    super('SsdMobilenetv1');\r\n  }\r\n\r\n  public forwardInput(input: NetInput) {\r\n    const { params } = this;\r\n\r\n    if (!params) {\r\n      throw new Error('SsdMobilenetv1 - load model before inference');\r\n    }\r\n\r\n    return tf.tidy(() => {\r\n      const batchTensor = tf.cast(input.toBatchTensor(512, false), 'float32');\r\n      const x = tf.sub(tf.mul(batchTensor, tf.scalar(0.007843137718737125)), tf.scalar(1)) as tf.Tensor4D;\r\n      const features = mobileNetV1(x, params.mobilenetv1);\r\n\r\n      const {\r\n        boxPredictions,\r\n        classPredictions,\r\n      } = predictionLayer(features.out, features.conv11, params.prediction_layer);\r\n\r\n      return outputLayer(boxPredictions, classPredictions, params.output_layer);\r\n    });\r\n  }\r\n\r\n  public async forward(input: TNetInput) {\r\n    return this.forwardInput(await toNetInput(input));\r\n  }\r\n\r\n  public async locateFaces(\r\n    input: TNetInput,\r\n    options: ISsdMobilenetv1Options = {},\r\n  ): Promise<FaceDetection[]> {\r\n    const { maxResults, minConfidence } = new SsdMobilenetv1Options(options);\r\n\r\n    const netInput = await toNetInput(input);\r\n\r\n    const {\r\n      boxes: _boxes,\r\n      scores: _scores,\r\n    } = this.forwardInput(netInput);\r\n\r\n    const boxes = _boxes[0];\r\n    const scores = _scores[0];\r\n    for (let i = 1; i < _boxes.length; i++) {\r\n      _boxes[i].dispose();\r\n      _scores[i].dispose();\r\n    }\r\n\r\n    const scoresData = Array.from(await scores.data());\r\n    const iouThreshold = 0.5;\r\n    const indices = nonMaxSuppression(\r\n      boxes,\r\n      scoresData as number[],\r\n      maxResults,\r\n      iouThreshold,\r\n      minConfidence,\r\n    );\r\n\r\n    const reshapedDims = netInput.getReshapedInputDimensions(0);\r\n    const inputSize = netInput.inputSize as number;\r\n    const padX = inputSize / reshapedDims.width;\r\n    const padY = inputSize / reshapedDims.height;\r\n\r\n    const boxesData = boxes.arraySync();\r\n    const results = indices\r\n      .map((idx) => {\r\n        const [top, bottom] = [\r\n          Math.max(0, boxesData[idx][0]),\r\n          Math.min(1.0, boxesData[idx][2]),\r\n        ].map((val) => val * padY);\r\n        const [left, right] = [\r\n          Math.max(0, boxesData[idx][1]),\r\n          Math.min(1.0, boxesData[idx][3]),\r\n        ].map((val) => val * padX);\r\n        return new FaceDetection(\r\n          scoresData[idx] as number,\r\n          new Rect(\r\n            left,\r\n            top,\r\n            right - left,\r\n            bottom - top,\r\n          ),\r\n          {\r\n            height: netInput.getInputHeight(0),\r\n            width: netInput.getInputWidth(0),\r\n          },\r\n        );\r\n      });\r\n\r\n    boxes.dispose();\r\n    scores.dispose();\r\n    return results;\r\n  }\r\n\r\n  protected getDefaultModelName(): string {\r\n    return 'ssd_mobilenetv1_model';\r\n  }\r\n\r\n  protected extractParamsFromWeightMap(weightMap: tf.NamedTensorMap) {\r\n    return extractParamsFromWeightMap(weightMap);\r\n  }\r\n\r\n  protected extractParams(weights: Float32Array) {\r\n    return extractParams(weights);\r\n  }\r\n}\r\n", "import * as tf from '../../dist/tfjs.esm';\r\n\r\nimport {\r\n  ExtractWeightsFunction, ParamMapping, ConvParams, extractWeightsFactory,\r\n} from '../common/index';\r\nimport {\r\n  MobileNetV1, NetParams, PointwiseConvParams, PredictionLayerParams,\r\n} from './types';\r\n\r\nfunction extractorsFactory(extractWeights: ExtractWeightsFunction, paramMappings: ParamMapping[]) {\r\n  function extractDepthwiseConvParams(numChannels: number, mappedPrefix: string): MobileNetV1.DepthwiseConvParams {\r\n    const filters = tf.tensor4d(extractWeights(3 * 3 * numChannels), [3, 3, numChannels, 1]);\r\n    const batch_norm_scale = tf.tensor1d(extractWeights(numChannels));\r\n    const batch_norm_offset = tf.tensor1d(extractWeights(numChannels));\r\n    const batch_norm_mean = tf.tensor1d(extractWeights(numChannels));\r\n    const batch_norm_variance = tf.tensor1d(extractWeights(numChannels));\r\n\r\n    paramMappings.push(\r\n      { paramPath: `${mappedPrefix}/filters` },\r\n      { paramPath: `${mappedPrefix}/batch_norm_scale` },\r\n      { paramPath: `${mappedPrefix}/batch_norm_offset` },\r\n      { paramPath: `${mappedPrefix}/batch_norm_mean` },\r\n      { paramPath: `${mappedPrefix}/batch_norm_variance` },\r\n    );\r\n\r\n    return {\r\n      filters,\r\n      batch_norm_scale,\r\n      batch_norm_offset,\r\n      batch_norm_mean,\r\n      batch_norm_variance,\r\n    };\r\n  }\r\n\r\n  function extractConvParams(\r\n    channelsIn: number,\r\n    channelsOut: number,\r\n    filterSize: number,\r\n    mappedPrefix: string,\r\n    isPointwiseConv?: boolean,\r\n  ): ConvParams {\r\n    const filters = tf.tensor4d(\r\n      extractWeights(channelsIn * channelsOut * filterSize * filterSize),\r\n      [filterSize, filterSize, channelsIn, channelsOut],\r\n    );\r\n    const bias = tf.tensor1d(extractWeights(channelsOut));\r\n\r\n    paramMappings.push(\r\n      { paramPath: `${mappedPrefix}/filters` },\r\n      { paramPath: `${mappedPrefix}/${isPointwiseConv ? 'batch_norm_offset' : 'bias'}` },\r\n    );\r\n\r\n    return { filters, bias };\r\n  }\r\n\r\n  function extractPointwiseConvParams(\r\n    channelsIn: number,\r\n    channelsOut: number,\r\n    filterSize: number,\r\n    mappedPrefix: string,\r\n  ): PointwiseConvParams {\r\n    const {\r\n      filters,\r\n      bias,\r\n    } = extractConvParams(channelsIn, channelsOut, filterSize, mappedPrefix, true);\r\n\r\n    return {\r\n      filters,\r\n      batch_norm_offset: bias,\r\n    };\r\n  }\r\n\r\n  function extractConvPairParams(\r\n    channelsIn: number,\r\n    channelsOut: number,\r\n    mappedPrefix: string,\r\n  ): MobileNetV1.ConvPairParams {\r\n    const depthwise_conv = extractDepthwiseConvParams(channelsIn, `${mappedPrefix}/depthwise_conv`);\r\n    const pointwise_conv = extractPointwiseConvParams(channelsIn, channelsOut, 1, `${mappedPrefix}/pointwise_conv`);\r\n\r\n    return { depthwise_conv, pointwise_conv };\r\n  }\r\n\r\n  function extractMobilenetV1Params(): MobileNetV1.Params {\r\n    const conv_0 = extractPointwiseConvParams(3, 32, 3, 'mobilenetv1/conv_0');\r\n    const conv_1 = extractConvPairParams(32, 64, 'mobilenetv1/conv_1');\r\n    const conv_2 = extractConvPairParams(64, 128, 'mobilenetv1/conv_2');\r\n    const conv_3 = extractConvPairParams(128, 128, 'mobilenetv1/conv_3');\r\n    const conv_4 = extractConvPairParams(128, 256, 'mobilenetv1/conv_4');\r\n    const conv_5 = extractConvPairParams(256, 256, 'mobilenetv1/conv_5');\r\n    const conv_6 = extractConvPairParams(256, 512, 'mobilenetv1/conv_6');\r\n    const conv_7 = extractConvPairParams(512, 512, 'mobilenetv1/conv_7');\r\n    const conv_8 = extractConvPairParams(512, 512, 'mobilenetv1/conv_8');\r\n    const conv_9 = extractConvPairParams(512, 512, 'mobilenetv1/conv_9');\r\n    const conv_10 = extractConvPairParams(512, 512, 'mobilenetv1/conv_10');\r\n    const conv_11 = extractConvPairParams(512, 512, 'mobilenetv1/conv_11');\r\n    const conv_12 = extractConvPairParams(512, 1024, 'mobilenetv1/conv_12');\r\n    const conv_13 = extractConvPairParams(1024, 1024, 'mobilenetv1/conv_13');\r\n    return {\r\n      conv_0,\r\n      conv_1,\r\n      conv_2,\r\n      conv_3,\r\n      conv_4,\r\n      conv_5,\r\n      conv_6,\r\n      conv_7,\r\n      conv_8,\r\n      conv_9,\r\n      conv_10,\r\n      conv_11,\r\n      conv_12,\r\n      conv_13,\r\n    };\r\n  }\r\n\r\n  function extractPredictionLayerParams(): PredictionLayerParams {\r\n    const conv_0 = extractPointwiseConvParams(1024, 256, 1, 'prediction_layer/conv_0');\r\n    const conv_1 = extractPointwiseConvParams(256, 512, 3, 'prediction_layer/conv_1');\r\n    const conv_2 = extractPointwiseConvParams(512, 128, 1, 'prediction_layer/conv_2');\r\n    const conv_3 = extractPointwiseConvParams(128, 256, 3, 'prediction_layer/conv_3');\r\n    const conv_4 = extractPointwiseConvParams(256, 128, 1, 'prediction_layer/conv_4');\r\n    const conv_5 = extractPointwiseConvParams(128, 256, 3, 'prediction_layer/conv_5');\r\n    const conv_6 = extractPointwiseConvParams(256, 64, 1, 'prediction_layer/conv_6');\r\n    const conv_7 = extractPointwiseConvParams(64, 128, 3, 'prediction_layer/conv_7');\r\n    const box_encoding_0_predictor = extractConvParams(512, 12, 1, 'prediction_layer/box_predictor_0/box_encoding_predictor');\r\n    const class_predictor_0 = extractConvParams(512, 9, 1, 'prediction_layer/box_predictor_0/class_predictor');\r\n    const box_encoding_1_predictor = extractConvParams(1024, 24, 1, 'prediction_layer/box_predictor_1/box_encoding_predictor');\r\n    const class_predictor_1 = extractConvParams(1024, 18, 1, 'prediction_layer/box_predictor_1/class_predictor');\r\n    const box_encoding_2_predictor = extractConvParams(512, 24, 1, 'prediction_layer/box_predictor_2/box_encoding_predictor');\r\n    const class_predictor_2 = extractConvParams(512, 18, 1, 'prediction_layer/box_predictor_2/class_predictor');\r\n    const box_encoding_3_predictor = extractConvParams(256, 24, 1, 'prediction_layer/box_predictor_3/box_encoding_predictor');\r\n    const class_predictor_3 = extractConvParams(256, 18, 1, 'prediction_layer/box_predictor_3/class_predictor');\r\n    const box_encoding_4_predictor = extractConvParams(256, 24, 1, 'prediction_layer/box_predictor_4/box_encoding_predictor');\r\n    const class_predictor_4 = extractConvParams(256, 18, 1, 'prediction_layer/box_predictor_4/class_predictor');\r\n    const box_encoding_5_predictor = extractConvParams(128, 24, 1, 'prediction_layer/box_predictor_5/box_encoding_predictor');\r\n    const class_predictor_5 = extractConvParams(128, 18, 1, 'prediction_layer/box_predictor_5/class_predictor');\r\n\r\n    const box_predictor_0 = {\r\n      box_encoding_predictor: box_encoding_0_predictor,\r\n      class_predictor: class_predictor_0,\r\n    };\r\n    const box_predictor_1 = {\r\n      box_encoding_predictor: box_encoding_1_predictor,\r\n      class_predictor: class_predictor_1,\r\n    };\r\n    const box_predictor_2 = {\r\n      box_encoding_predictor: box_encoding_2_predictor,\r\n      class_predictor: class_predictor_2,\r\n    };\r\n    const box_predictor_3 = {\r\n      box_encoding_predictor: box_encoding_3_predictor,\r\n      class_predictor: class_predictor_3,\r\n    };\r\n    const box_predictor_4 = {\r\n      box_encoding_predictor: box_encoding_4_predictor,\r\n      class_predictor: class_predictor_4,\r\n    };\r\n    const box_predictor_5 = {\r\n      box_encoding_predictor: box_encoding_5_predictor,\r\n      class_predictor: class_predictor_5,\r\n    };\r\n    return {\r\n      conv_0,\r\n      conv_1,\r\n      conv_2,\r\n      conv_3,\r\n      conv_4,\r\n      conv_5,\r\n      conv_6,\r\n      conv_7,\r\n      box_predictor_0,\r\n      box_predictor_1,\r\n      box_predictor_2,\r\n      box_predictor_3,\r\n      box_predictor_4,\r\n      box_predictor_5,\r\n    };\r\n  }\r\n\r\n  return {\r\n    extractMobilenetV1Params,\r\n    extractPredictionLayerParams,\r\n  };\r\n}\r\n\r\nexport function extractParams(weights: Float32Array): { params: NetParams, paramMappings: ParamMapping[] } {\r\n  const paramMappings: ParamMapping[] = [];\r\n  const {\r\n    extractWeights,\r\n    getRemainingWeights,\r\n  } = extractWeightsFactory(weights);\r\n  const {\r\n    extractMobilenetV1Params,\r\n    extractPredictionLayerParams,\r\n  } = extractorsFactory(extractWeights, paramMappings);\r\n  const mobilenetv1 = extractMobilenetV1Params();\r\n  const prediction_layer = extractPredictionLayerParams();\r\n  const extra_dim = tf.tensor3d(\r\n    extractWeights(5118 * 4),\r\n    [1, 5118, 4],\r\n  );\r\n  const output_layer = {\r\n    extra_dim,\r\n  };\r\n  paramMappings.push({ paramPath: 'output_layer/extra_dim' });\r\n  if (getRemainingWeights().length !== 0) {\r\n    throw new Error(`weights remaing after extract: ${getRemainingWeights().length}`);\r\n  }\r\n\r\n  return {\r\n    params: {\r\n      mobilenetv1,\r\n      prediction_layer,\r\n      output_layer,\r\n    },\r\n    paramMappings,\r\n  };\r\n}\r\n", "import * as tf from '../../dist/tfjs.esm';\r\n\r\nimport {\r\n  ConvParams, disposeUnusedWeightTensors, extractWeightEntryFactory, ParamMapping,\r\n} from '../common/index';\r\nimport { isTensor3D } from '../utils/index';\r\nimport {\r\n  BoxPredictionParams, MobileNetV1, NetParams, PointwiseConvParams, PredictionLayerParams,\r\n} from './types';\r\n\r\nfunction extractorsFactory(weightMap: any, paramMappings: ParamMapping[]) {\r\n  const extractWeightEntry = extractWeightEntryFactory(weightMap, paramMappings);\r\n\r\n  function extractPointwiseConvParams(prefix: string, idx: number, mappedPrefix: string): PointwiseConvParams {\r\n    const filters = extractWeightEntry(`${prefix}/Conv2d_${idx}_pointwise/weights`, 4, `${mappedPrefix}/filters`);\r\n    const batch_norm_offset = extractWeightEntry(`${prefix}/Conv2d_${idx}_pointwise/convolution_bn_offset`, 1, `${mappedPrefix}/batch_norm_offset`);\r\n    return { filters, batch_norm_offset };\r\n  }\r\n\r\n  function extractConvPairParams(idx: number): MobileNetV1.ConvPairParams {\r\n    const mappedPrefix = `mobilenetv1/conv_${idx}`;\r\n    const prefixDepthwiseConv = `MobilenetV1/Conv2d_${idx}_depthwise`;\r\n    const mappedPrefixDepthwiseConv = `${mappedPrefix}/depthwise_conv`;\r\n    const mappedPrefixPointwiseConv = `${mappedPrefix}/pointwise_conv`;\r\n\r\n    const filters = extractWeightEntry(`${prefixDepthwiseConv}/depthwise_weights`, 4, `${mappedPrefixDepthwiseConv}/filters`);\r\n    const batch_norm_scale = extractWeightEntry(`${prefixDepthwiseConv}/BatchNorm/gamma`, 1, `${mappedPrefixDepthwiseConv}/batch_norm_scale`);\r\n    const batch_norm_offset = extractWeightEntry(`${prefixDepthwiseConv}/BatchNorm/beta`, 1, `${mappedPrefixDepthwiseConv}/batch_norm_offset`);\r\n    const batch_norm_mean = extractWeightEntry(`${prefixDepthwiseConv}/BatchNorm/moving_mean`, 1, `${mappedPrefixDepthwiseConv}/batch_norm_mean`);\r\n    const batch_norm_variance = extractWeightEntry(`${prefixDepthwiseConv}/BatchNorm/moving_variance`, 1, `${mappedPrefixDepthwiseConv}/batch_norm_variance`);\r\n\r\n    return {\r\n      depthwise_conv: {\r\n        filters,\r\n        batch_norm_scale,\r\n        batch_norm_offset,\r\n        batch_norm_mean,\r\n        batch_norm_variance,\r\n      },\r\n      pointwise_conv: extractPointwiseConvParams('MobilenetV1', idx, mappedPrefixPointwiseConv),\r\n    };\r\n  }\r\n\r\n  function extractMobilenetV1Params(): MobileNetV1.Params {\r\n    return {\r\n      conv_0: extractPointwiseConvParams('MobilenetV1', 0, 'mobilenetv1/conv_0'),\r\n      conv_1: extractConvPairParams(1),\r\n      conv_2: extractConvPairParams(2),\r\n      conv_3: extractConvPairParams(3),\r\n      conv_4: extractConvPairParams(4),\r\n      conv_5: extractConvPairParams(5),\r\n      conv_6: extractConvPairParams(6),\r\n      conv_7: extractConvPairParams(7),\r\n      conv_8: extractConvPairParams(8),\r\n      conv_9: extractConvPairParams(9),\r\n      conv_10: extractConvPairParams(10),\r\n      conv_11: extractConvPairParams(11),\r\n      conv_12: extractConvPairParams(12),\r\n      conv_13: extractConvPairParams(13),\r\n    };\r\n  }\r\n\r\n  function extractConvParams(prefix: string, mappedPrefix: string): ConvParams {\r\n    const filters = extractWeightEntry(`${prefix}/weights`, 4, `${mappedPrefix}/filters`);\r\n    const bias = extractWeightEntry(`${prefix}/biases`, 1, `${mappedPrefix}/bias`);\r\n    return { filters, bias };\r\n  }\r\n\r\n  function extractBoxPredictorParams(idx: number): BoxPredictionParams {\r\n    const box_encoding_predictor = extractConvParams(\r\n      `Prediction/BoxPredictor_${idx}/BoxEncodingPredictor`,\r\n      `prediction_layer/box_predictor_${idx}/box_encoding_predictor`,\r\n    );\r\n    const class_predictor = extractConvParams(\r\n      `Prediction/BoxPredictor_${idx}/ClassPredictor`,\r\n      `prediction_layer/box_predictor_${idx}/class_predictor`,\r\n    );\r\n    return { box_encoding_predictor, class_predictor };\r\n  }\r\n\r\n  function extractPredictionLayerParams(): PredictionLayerParams {\r\n    return {\r\n      conv_0: extractPointwiseConvParams('Prediction', 0, 'prediction_layer/conv_0'),\r\n      conv_1: extractPointwiseConvParams('Prediction', 1, 'prediction_layer/conv_1'),\r\n      conv_2: extractPointwiseConvParams('Prediction', 2, 'prediction_layer/conv_2'),\r\n      conv_3: extractPointwiseConvParams('Prediction', 3, 'prediction_layer/conv_3'),\r\n      conv_4: extractPointwiseConvParams('Prediction', 4, 'prediction_layer/conv_4'),\r\n      conv_5: extractPointwiseConvParams('Prediction', 5, 'prediction_layer/conv_5'),\r\n      conv_6: extractPointwiseConvParams('Prediction', 6, 'prediction_layer/conv_6'),\r\n      conv_7: extractPointwiseConvParams('Prediction', 7, 'prediction_layer/conv_7'),\r\n      box_predictor_0: extractBoxPredictorParams(0),\r\n      box_predictor_1: extractBoxPredictorParams(1),\r\n      box_predictor_2: extractBoxPredictorParams(2),\r\n      box_predictor_3: extractBoxPredictorParams(3),\r\n      box_predictor_4: extractBoxPredictorParams(4),\r\n      box_predictor_5: extractBoxPredictorParams(5),\r\n    };\r\n  }\r\n\r\n  return {\r\n    extractMobilenetV1Params,\r\n    extractPredictionLayerParams,\r\n  };\r\n}\r\n\r\nexport function extractParamsFromWeightMap(\r\n  weightMap: tf.NamedTensorMap,\r\n): { params: NetParams, paramMappings: ParamMapping[] } {\r\n  const paramMappings: ParamMapping[] = [];\r\n  const {\r\n    extractMobilenetV1Params,\r\n    extractPredictionLayerParams,\r\n  } = extractorsFactory(weightMap, paramMappings);\r\n  const extra_dim = weightMap['Output/extra_dim'];\r\n  paramMappings.push({ originalPath: 'Output/extra_dim', paramPath: 'output_layer/extra_dim' });\r\n  if (!isTensor3D(extra_dim)) {\r\n    throw new Error(`expected weightMap['Output/extra_dim'] to be a Tensor3D, instead have ${extra_dim}`);\r\n  }\r\n\r\n  const params = {\r\n    mobilenetv1: extractMobilenetV1Params(),\r\n    prediction_layer: extractPredictionLayerParams(),\r\n    output_layer: {\r\n      extra_dim,\r\n    },\r\n  };\r\n\r\n  disposeUnusedWeightTensors(weightMap, paramMappings);\r\n  return { params, paramMappings };\r\n}\r\n", "import * as tf from '../../dist/tfjs.esm';\r\n\r\nimport { pointwiseConvLayer } from './pointwiseConvLayer';\r\nimport { MobileNetV1 } from './types';\r\n\r\nconst epsilon = 0.0010000000474974513;\r\n\r\nfunction depthwiseConvLayer(\r\n  x: tf.Tensor4D,\r\n  params: MobileNetV1.DepthwiseConvParams,\r\n  strides: [number, number],\r\n) {\r\n  return tf.tidy(() => {\r\n    let out = tf.depthwiseConv2d(x, params.filters, strides, 'same');\r\n    out = tf.batchNorm<tf.Rank.R4>(\r\n      out,\r\n      params.batch_norm_mean,\r\n      params.batch_norm_variance,\r\n      params.batch_norm_offset,\r\n      params.batch_norm_scale,\r\n      epsilon,\r\n    );\r\n    return tf.clipByValue(out, 0, 6);\r\n  });\r\n}\r\n\r\nfunction getStridesForLayerIdx(layerIdx: number): [number, number] {\r\n  return [2, 4, 6, 12].some((idx) => idx === layerIdx) ? [2, 2] : [1, 1];\r\n}\r\n\r\nexport function mobileNetV1(x: tf.Tensor4D, params: MobileNetV1.Params) {\r\n  return tf.tidy(() => {\r\n    let conv11;\r\n    let out = pointwiseConvLayer(x, params.conv_0, [2, 2]);\r\n\r\n    const convPairParams = [\r\n      params.conv_1,\r\n      params.conv_2,\r\n      params.conv_3,\r\n      params.conv_4,\r\n      params.conv_5,\r\n      params.conv_6,\r\n      params.conv_7,\r\n      params.conv_8,\r\n      params.conv_9,\r\n      params.conv_10,\r\n      params.conv_11,\r\n      params.conv_12,\r\n      params.conv_13,\r\n    ];\r\n\r\n    convPairParams.forEach((param, i) => {\r\n      const layerIdx = i + 1;\r\n      const depthwiseConvStrides = getStridesForLayerIdx(layerIdx);\r\n      out = depthwiseConvLayer(out, param.depthwise_conv, depthwiseConvStrides);\r\n      out = pointwiseConvLayer(out, param.pointwise_conv, [1, 1]);\r\n      if (layerIdx === 11) {\r\n        conv11 = out;\r\n      }\r\n    });\r\n\r\n    if (conv11 === null) {\r\n      throw new Error('mobileNetV1 - output of conv layer 11 is null');\r\n    }\r\n\r\n    return {\r\n      out,\r\n      conv11: conv11 as any,\r\n    };\r\n  });\r\n}\r\n", "import * as tf from '../../dist/tfjs.esm';\r\n\r\nimport { PointwiseConvParams } from './types';\r\n\r\nexport function pointwiseConvLayer(\r\n  x: tf.Tensor4D,\r\n  params: PointwiseConvParams,\r\n  strides: [number, number],\r\n) {\r\n  return tf.tidy(() => {\r\n    let out = tf.conv2d(x, params.filters, strides, 'same');\r\n    out = tf.add(out, params.batch_norm_offset);\r\n    return tf.clipByValue(out, 0, 6);\r\n  });\r\n}\r\n", "import * as tf from '../../dist/tfjs.esm';\r\n\r\nfunction IOU(boxes: tf.Tensor2D, i: number, j: number) {\r\n  const boxesData = boxes.arraySync();\r\n  const yminI = Math.min(boxesData[i][0], boxesData[i][2]);\r\n  const xminI = Math.min(boxesData[i][1], boxesData[i][3]);\r\n  const ymaxI = Math.max(boxesData[i][0], boxesData[i][2]);\r\n  const xmaxI = Math.max(boxesData[i][1], boxesData[i][3]);\r\n  const yminJ = Math.min(boxesData[j][0], boxesData[j][2]);\r\n  const xminJ = Math.min(boxesData[j][1], boxesData[j][3]);\r\n  const ymaxJ = Math.max(boxesData[j][0], boxesData[j][2]);\r\n  const xmaxJ = Math.max(boxesData[j][1], boxesData[j][3]);\r\n  const areaI = (ymaxI - yminI) * (xmaxI - xminI);\r\n  const areaJ = (ymaxJ - yminJ) * (xmaxJ - xminJ);\r\n  if (areaI <= 0 || areaJ <= 0) {\r\n    return 0.0;\r\n  }\r\n  const intersectionYmin = Math.max(yminI, yminJ);\r\n  const intersectionXmin = Math.max(xminI, xminJ);\r\n  const intersectionYmax = Math.min(ymaxI, ymaxJ);\r\n  const intersectionXmax = Math.min(xmaxI, xmaxJ);\r\n  const intersectionArea = Math.max(intersectionYmax - intersectionYmin, 0.0)\r\n      * Math.max(intersectionXmax - intersectionXmin, 0.0);\r\n  return intersectionArea / (areaI + areaJ - intersectionArea);\r\n}\r\n\r\nexport function nonMaxSuppression(\r\n  boxes: tf.Tensor2D,\r\n  scores: number[],\r\n  maxOutputSize: number,\r\n  iouThreshold: number,\r\n  scoreThreshold: number,\r\n): number[] {\r\n  const numBoxes = boxes.shape[0];\r\n  const outputSize = Math.min(\r\n    maxOutputSize,\r\n    numBoxes,\r\n  );\r\n\r\n  const candidates = scores\r\n    .map((score, boxIndex) => ({ score, boxIndex }))\r\n    .filter((c) => c.score > scoreThreshold)\r\n    .sort((c1, c2) => c2.score - c1.score);\r\n\r\n  const suppressFunc = (x: number) => (x <= iouThreshold ? 1 : 0);\r\n  const selected: number[] = [];\r\n\r\n  candidates.forEach((c) => {\r\n    if (selected.length >= outputSize) return;\r\n    const originalScore = c.score;\r\n    for (let j = selected.length - 1; j >= 0; --j) {\r\n      const iou = IOU(boxes, c.boxIndex, selected[j]);\r\n      if (iou === 0.0) continue;\r\n      c.score *= suppressFunc(iou);\r\n      if (c.score <= scoreThreshold) break;\r\n    }\r\n    if (originalScore === c.score) {\r\n      selected.push(c.boxIndex);\r\n    }\r\n  });\r\n  return selected;\r\n}\r\n", "import * as tf from '../../dist/tfjs.esm';\r\n\r\nimport { OutputLayerParams } from './types';\r\n\r\nfunction getCenterCoordinatesAndSizesLayer(x: tf.Tensor2D) {\r\n  const vec = tf.unstack(tf.transpose(x, [1, 0]));\r\n\r\n  const sizes = [\r\n    tf.sub(vec[2], vec[0]),\r\n    tf.sub(vec[3], vec[1]),\r\n  ];\r\n  const centers = [\r\n    tf.add(vec[0], tf.div(sizes[0], tf.scalar(2))),\r\n    tf.add(vec[1], tf.div(sizes[1], tf.scalar(2))),\r\n  ];\r\n  return {\r\n    sizes,\r\n    centers,\r\n  };\r\n}\r\n\r\nfunction decodeBoxesLayer(x0: tf.Tensor2D, x1: tf.Tensor2D) {\r\n  const {\r\n    sizes,\r\n    centers,\r\n  } = getCenterCoordinatesAndSizesLayer(x0);\r\n\r\n  const vec = tf.unstack(tf.transpose(x1, [1, 0]));\r\n  const div0_out = tf.div(tf.mul(tf.exp(tf.div(vec[2], tf.scalar(5))), sizes[0]), tf.scalar(2));\r\n  const add0_out = tf.add(tf.mul(tf.div(vec[0], tf.scalar(10)), sizes[0]), centers[0]);\r\n  const div1_out = tf.div(tf.mul(tf.exp(tf.div(vec[3], tf.scalar(5))), sizes[1]), tf.scalar(2));\r\n  const add1_out = tf.add(tf.mul(tf.div(vec[1], tf.scalar(10)), sizes[1]), centers[1]);\r\n\r\n  return tf.transpose(\r\n    tf.stack([\r\n      tf.sub(add0_out, div0_out),\r\n      tf.sub(add1_out, div1_out),\r\n      tf.add(add0_out, div0_out),\r\n      tf.add(add1_out, div1_out),\r\n    ]),\r\n    [1, 0],\r\n  );\r\n}\r\n\r\nexport function outputLayer(\r\n  boxPredictions: tf.Tensor4D,\r\n  classPredictions: tf.Tensor4D,\r\n  params: OutputLayerParams,\r\n) {\r\n  return tf.tidy(() => {\r\n    const batchSize = boxPredictions.shape[0];\r\n\r\n    let boxes = decodeBoxesLayer(\r\n      tf.reshape(tf.tile(params.extra_dim, [batchSize, 1, 1]), [-1, 4]) as tf.Tensor2D,\r\n      tf.reshape(boxPredictions, [-1, 4]) as tf.Tensor2D,\r\n    );\r\n    boxes = tf.reshape(\r\n      boxes,\r\n      [batchSize, (boxes.shape[0] / batchSize), 4],\r\n    );\r\n\r\n    const scoresAndClasses = tf.sigmoid(tf.slice(classPredictions, [0, 0, 1], [-1, -1, -1]));\r\n    let scores = tf.slice(scoresAndClasses, [0, 0, 0], [-1, -1, 1]) as tf.Tensor;\r\n\r\n    scores = tf.reshape(\r\n      scores,\r\n      [batchSize, scores.shape[1] as number],\r\n    );\r\n\r\n    const boxesByBatch = tf.unstack(boxes) as tf.Tensor2D[];\r\n    const scoresByBatch = tf.unstack(scores) as tf.Tensor1D[];\r\n\r\n    return {\r\n      boxes: boxesByBatch,\r\n      scores: scoresByBatch,\r\n    };\r\n  });\r\n}\r\n", "import * as tf from '../../dist/tfjs.esm';\r\n\r\nimport { boxPredictionLayer } from './boxPredictionLayer';\r\nimport { pointwiseConvLayer } from './pointwiseConvLayer';\r\nimport { PredictionLayerParams } from './types';\r\n\r\nexport function predictionLayer(\r\n  x: tf.Tensor4D,\r\n  conv11: tf.Tensor4D,\r\n  params: PredictionLayerParams,\r\n) {\r\n  return tf.tidy(() => {\r\n    const conv0 = pointwiseConvLayer(x, params.conv_0, [1, 1]);\r\n    const conv1 = pointwiseConvLayer(conv0, params.conv_1, [2, 2]);\r\n    const conv2 = pointwiseConvLayer(conv1, params.conv_2, [1, 1]);\r\n    const conv3 = pointwiseConvLayer(conv2, params.conv_3, [2, 2]);\r\n    const conv4 = pointwiseConvLayer(conv3, params.conv_4, [1, 1]);\r\n    const conv5 = pointwiseConvLayer(conv4, params.conv_5, [2, 2]);\r\n    const conv6 = pointwiseConvLayer(conv5, params.conv_6, [1, 1]);\r\n    const conv7 = pointwiseConvLayer(conv6, params.conv_7, [2, 2]);\r\n\r\n    const boxPrediction0 = boxPredictionLayer(conv11, params.box_predictor_0);\r\n    const boxPrediction1 = boxPredictionLayer(x, params.box_predictor_1);\r\n    const boxPrediction2 = boxPredictionLayer(conv1, params.box_predictor_2);\r\n    const boxPrediction3 = boxPredictionLayer(conv3, params.box_predictor_3);\r\n    const boxPrediction4 = boxPredictionLayer(conv5, params.box_predictor_4);\r\n    const boxPrediction5 = boxPredictionLayer(conv7, params.box_predictor_5);\r\n\r\n    const boxPredictions = tf.concat([\r\n      boxPrediction0.boxPredictionEncoding,\r\n      boxPrediction1.boxPredictionEncoding,\r\n      boxPrediction2.boxPredictionEncoding,\r\n      boxPrediction3.boxPredictionEncoding,\r\n      boxPrediction4.boxPredictionEncoding,\r\n      boxPrediction5.boxPredictionEncoding,\r\n    ], 1) as tf.Tensor4D;\r\n\r\n    const classPredictions = tf.concat([\r\n      boxPrediction0.classPrediction,\r\n      boxPrediction1.classPrediction,\r\n      boxPrediction2.classPrediction,\r\n      boxPrediction3.classPrediction,\r\n      boxPrediction4.classPrediction,\r\n      boxPrediction5.classPrediction,\r\n    ], 1) as tf.Tensor4D;\r\n\r\n    return {\r\n      boxPredictions,\r\n      classPredictions,\r\n    };\r\n  });\r\n}\r\n", "import * as tf from '../../dist/tfjs.esm';\r\n\r\nimport { convLayer } from '../common/index';\r\nimport { BoxPredictionParams } from './types';\r\n\r\nexport function boxPredictionLayer(\r\n  x: tf.Tensor4D,\r\n  params: BoxPredictionParams,\r\n) {\r\n  return tf.tidy(() => {\r\n    const batchSize = x.shape[0];\r\n    const boxPredictionEncoding = tf.reshape(\r\n      convLayer(x, params.box_encoding_predictor),\r\n      [batchSize, -1, 1, 4],\r\n    );\r\n    const classPrediction = tf.reshape(\r\n      convLayer(x, params.class_predictor),\r\n      [batchSize, -1, 3],\r\n    );\r\n    return { boxPredictionEncoding, classPrediction };\r\n  });\r\n}\r\n", "export interface ISsdMobilenetv1Options {\r\n  minConfidence?: number\r\n  maxResults?: number\r\n}\r\n\r\nexport class SsdMobilenetv1Options {\r\n  protected _name: string = 'SsdMobilenetv1Options'\r\n\r\n  private _minConfidence: number\r\n\r\n  private _maxResults: number\r\n\r\n  constructor({ minConfidence, maxResults }: ISsdMobilenetv1Options = {}) {\r\n    this._minConfidence = minConfidence || 0.5;\r\n    this._maxResults = maxResults || 100;\r\n\r\n    if (typeof this._minConfidence !== 'number' || this._minConfidence <= 0 || this._minConfidence >= 1) {\r\n      throw new Error(`${this._name} - expected minConfidence to be a number between 0 and 1`);\r\n    }\r\n\r\n    if (typeof this._maxResults !== 'number') {\r\n      throw new Error(`${this._name} - expected maxResults to be a number`);\r\n    }\r\n  }\r\n\r\n  get minConfidence(): number { return this._minConfidence; }\r\n\r\n  get maxResults(): number { return this._maxResults; }\r\n}\r\n", "import { SsdMobilenetv1 } from './SsdMobilenetv1';\r\n\r\nexport * from './SsdMobilenetv1';\r\nexport * from './SsdMobilenetv1Options';\r\n\r\nexport function createSsdMobilenetv1(weights: Float32Array) {\r\n  const net = new SsdMobilenetv1();\r\n  net.extractWeights(weights);\r\n  return net;\r\n}\r\n\r\nexport function createFaceDetectionNet(weights: Float32Array) {\r\n  return createSsdMobilenetv1(weights);\r\n}\r\n\r\n// alias for backward compatibily\r\nexport class FaceDetectionNet extends SsdMobilenetv1 {}\r\n", "import { Point } from '../classes/index';\r\n\r\nexport const IOU_THRESHOLD = 0.4;\r\n\r\nexport const BOX_ANCHORS = [\r\n  new Point(0.738768, 0.874946),\r\n  new Point(2.42204, 2.65704),\r\n  new Point(4.30971, 7.04493),\r\n  new Point(10.246, 4.59428),\r\n  new Point(12.6868, 11.8741),\r\n];\r\n\r\nexport const BOX_ANCHORS_SEPARABLE = [\r\n  new Point(1.603231, 2.094468),\r\n  new Point(6.041143, 7.080126),\r\n  new Point(2.882459, 3.518061),\r\n  new Point(4.266906, 5.178857),\r\n  new Point(9.041765, 10.66308),\r\n];\r\n\r\nexport const MEAN_RGB_SEPARABLE: [number, number, number] = [117.001, 114.697, 97.404];\r\n\r\nexport const DEFAULT_MODEL_NAME = 'tiny_yolov2_model';\r\nexport const DEFAULT_MODEL_NAME_SEPARABLE_CONV = 'tiny_yolov2_separable_conv_model';\r\n", "import * as tf from '../../dist/tfjs.esm';\r\n\r\nimport { BoundingBox } from '../classes/BoundingBox';\r\nimport { Dimensions } from '../classes/Dimensions';\r\nimport { ObjectDetection } from '../classes/ObjectDetection';\r\nimport { convLayer } from '../common/index';\r\nimport { ConvParams, SeparableConvParams } from '../common/types';\r\nimport { toNetInput } from '../dom/index';\r\nimport { NetInput } from '../dom/NetInput';\r\nimport { TNetInput } from '../dom/types';\r\nimport { NeuralNetwork } from '../NeuralNetwork';\r\nimport { sigmoid } from '../ops/index';\r\nimport { nonMaxSuppression } from '../ops/nonMaxSuppression';\r\nimport { normalize } from '../ops/normalize';\r\nimport { TinyYolov2Config, validateConfig } from './config';\r\nimport { convWithBatchNorm } from './convWithBatchNorm';\r\nimport { depthwiseSeparableConv } from './depthwiseSeparableConv';\r\nimport { extractParams } from './extractParams';\r\nimport { extractParamsFromWeightMap } from './extractParamsFromWeightMap';\r\nimport { leaky } from './leaky';\r\nimport { ITinyYolov2Options, TinyYolov2Options } from './TinyYolov2Options';\r\nimport { DefaultTinyYolov2NetParams, MobilenetParams, TinyYolov2NetParams } from './types';\r\n\r\nexport class TinyYolov2Base extends NeuralNetwork<TinyYolov2NetParams> {\r\n  public static DEFAULT_FILTER_SIZES = [3, 16, 32, 64, 128, 256, 512, 1024, 1024];\r\n\r\n  private _config: TinyYolov2Config\r\n\r\n  constructor(config: TinyYolov2Config) {\r\n    super('TinyYolov2');\r\n    validateConfig(config);\r\n    this._config = config;\r\n  }\r\n\r\n  public get config(): TinyYolov2Config {\r\n    return this._config;\r\n  }\r\n\r\n  public get withClassScores(): boolean {\r\n    return this.config.withClassScores || this.config.classes.length > 1;\r\n  }\r\n\r\n  public get boxEncodingSize(): number {\r\n    return 5 + (this.withClassScores ? this.config.classes.length : 0);\r\n  }\r\n\r\n  public runTinyYolov2(x: tf.Tensor4D, params: DefaultTinyYolov2NetParams): tf.Tensor4D {\r\n    let out = convWithBatchNorm(x, params.conv0);\r\n    out = tf.maxPool(out, [2, 2], [2, 2], 'same');\r\n    out = convWithBatchNorm(out, params.conv1);\r\n    out = tf.maxPool(out, [2, 2], [2, 2], 'same');\r\n    out = convWithBatchNorm(out, params.conv2);\r\n    out = tf.maxPool(out, [2, 2], [2, 2], 'same');\r\n    out = convWithBatchNorm(out, params.conv3);\r\n    out = tf.maxPool(out, [2, 2], [2, 2], 'same');\r\n    out = convWithBatchNorm(out, params.conv4);\r\n    out = tf.maxPool(out, [2, 2], [2, 2], 'same');\r\n    out = convWithBatchNorm(out, params.conv5);\r\n    out = tf.maxPool(out, [2, 2], [1, 1], 'same');\r\n    out = convWithBatchNorm(out, params.conv6);\r\n    out = convWithBatchNorm(out, params.conv7);\r\n    return convLayer(out, params.conv8, 'valid', false);\r\n  }\r\n\r\n  public runMobilenet(x: tf.Tensor4D, params: MobilenetParams): tf.Tensor4D {\r\n    let out = this.config.isFirstLayerConv2d\r\n      ? leaky(convLayer(x, params.conv0 as ConvParams, 'valid', false))\r\n      : depthwiseSeparableConv(x, params.conv0 as SeparableConvParams);\r\n    out = tf.maxPool(out, [2, 2], [2, 2], 'same');\r\n    out = depthwiseSeparableConv(out, params.conv1);\r\n    out = tf.maxPool(out, [2, 2], [2, 2], 'same');\r\n    out = depthwiseSeparableConv(out, params.conv2);\r\n    out = tf.maxPool(out, [2, 2], [2, 2], 'same');\r\n    out = depthwiseSeparableConv(out, params.conv3);\r\n    out = tf.maxPool(out, [2, 2], [2, 2], 'same');\r\n    out = depthwiseSeparableConv(out, params.conv4);\r\n    out = tf.maxPool(out, [2, 2], [2, 2], 'same');\r\n    out = depthwiseSeparableConv(out, params.conv5);\r\n    out = tf.maxPool(out, [2, 2], [1, 1], 'same');\r\n    out = params.conv6 ? depthwiseSeparableConv(out, params.conv6) : out;\r\n    out = params.conv7 ? depthwiseSeparableConv(out, params.conv7) : out;\r\n    return convLayer(out, params.conv8, 'valid', false);\r\n  }\r\n\r\n  public forwardInput(input: NetInput, inputSize: number): tf.Tensor4D {\r\n    const { params } = this;\r\n\r\n    if (!params) {\r\n      throw new Error('TinyYolov2 - load model before inference');\r\n    }\r\n\r\n    return tf.tidy(() => {\r\n      let batchTensor = tf.cast(input.toBatchTensor(inputSize, false), 'float32');\r\n      batchTensor = this.config.meanRgb\r\n        ? normalize(batchTensor, this.config.meanRgb)\r\n        : batchTensor;\r\n      batchTensor = batchTensor.div(tf.scalar(256)) as tf.Tensor4D;\r\n      return this.config.withSeparableConvs\r\n        ? this.runMobilenet(batchTensor, params as MobilenetParams)\r\n        : this.runTinyYolov2(batchTensor, params as DefaultTinyYolov2NetParams);\r\n    });\r\n  }\r\n\r\n  public async forward(input: TNetInput, inputSize: number): Promise<tf.Tensor4D> {\r\n    return this.forwardInput(await toNetInput(input), inputSize);\r\n  }\r\n\r\n  public async detect(input: TNetInput, forwardParams: ITinyYolov2Options = {}): Promise<ObjectDetection[]> {\r\n    const { inputSize, scoreThreshold } = new TinyYolov2Options(forwardParams);\r\n    const netInput = await toNetInput(input);\r\n    const out = await this.forwardInput(netInput, inputSize);\r\n    const out0 = tf.tidy(() => tf.unstack(out)[0].expandDims()) as tf.Tensor4D;\r\n    const inputDimensions = {\r\n      width: netInput.getInputWidth(0),\r\n      height: netInput.getInputHeight(0),\r\n    };\r\n\r\n    const results = await this.extractBoxes(out0, netInput.getReshapedInputDimensions(0), scoreThreshold);\r\n    out.dispose();\r\n    out0.dispose();\r\n\r\n    const boxes = results.map((res) => res.box);\r\n    const scores = results.map((res) => res.score);\r\n    const classScores = results.map((res) => res.classScore);\r\n    const classNames = results.map((res) => this.config.classes[res.label]);\r\n\r\n    const indices = nonMaxSuppression(\r\n      boxes.map((box) => box.rescale(inputSize)),\r\n      scores,\r\n      this.config.iouThreshold,\r\n      true,\r\n    );\r\n\r\n    const detections = indices.map((idx) => new ObjectDetection(\r\n      scores[idx],\r\n      classScores[idx],\r\n      classNames[idx],\r\n      boxes[idx],\r\n      inputDimensions,\r\n    ));\r\n    return detections;\r\n  }\r\n\r\n  protected getDefaultModelName(): string {\r\n    return '';\r\n  }\r\n\r\n  protected extractParamsFromWeightMap(weightMap: tf.NamedTensorMap) {\r\n    return extractParamsFromWeightMap(weightMap, this.config);\r\n  }\r\n\r\n  protected extractParams(weights: Float32Array) {\r\n    const filterSizes = this.config.filterSizes || TinyYolov2Base.DEFAULT_FILTER_SIZES;\r\n\r\n    const numFilters = filterSizes ? filterSizes.length : undefined;\r\n    if (numFilters !== 7 && numFilters !== 8 && numFilters !== 9) {\r\n      throw new Error(`TinyYolov2 - expected 7 | 8 | 9 convolutional filters, but found ${numFilters} filterSizes in config`);\r\n    }\r\n    return extractParams(weights, this.config, this.boxEncodingSize, filterSizes);\r\n  }\r\n\r\n  protected async extractBoxes(\r\n    outputTensor: tf.Tensor4D,\r\n    inputBlobDimensions: Dimensions,\r\n    scoreThreshold?: number,\r\n  ) {\r\n    const { width, height } = inputBlobDimensions;\r\n    const inputSize = Math.max(width, height);\r\n    const correctionFactorX = inputSize / width;\r\n    const correctionFactorY = inputSize / height;\r\n\r\n    const numCells = outputTensor.shape[1];\r\n    const numBoxes = this.config.anchors.length;\r\n\r\n    const [boxesTensor, scoresTensor, classScoresTensor] = tf.tidy(() => {\r\n      const reshaped = outputTensor.reshape([numCells, numCells, numBoxes, this.boxEncodingSize]);\r\n\r\n      const boxes = reshaped.slice([0, 0, 0, 0], [numCells, numCells, numBoxes, 4]);\r\n      const scores = reshaped.slice([0, 0, 0, 4], [numCells, numCells, numBoxes, 1]);\r\n      const classScores = this.withClassScores\r\n        ? tf.softmax(reshaped.slice([0, 0, 0, 5], [numCells, numCells, numBoxes, this.config.classes.length]), 3)\r\n        : tf.scalar(0);\r\n      return [boxes, scores, classScores];\r\n    });\r\n\r\n    const results = [] as any;\r\n    const scoresData = await scoresTensor.array();\r\n    const boxesData = await boxesTensor.array();\r\n    for (let row = 0; row < numCells; row++) {\r\n      for (let col = 0; col < numCells; col++) {\r\n        for (let anchor = 0; anchor < numBoxes; anchor++) {\r\n          const score = sigmoid(scoresData[row][col][anchor][0]);\r\n          if (!scoreThreshold || score > scoreThreshold) {\r\n            const ctX = ((col + sigmoid(boxesData[row][col][anchor][0])) / numCells) * correctionFactorX;\r\n            const ctY = ((row + sigmoid(boxesData[row][col][anchor][1])) / numCells) * correctionFactorY;\r\n            const widthLocal = ((Math.exp(boxesData[row][col][anchor][2]) * this.config.anchors[anchor].x) / numCells) * correctionFactorX;\r\n            const heightLocal = ((Math.exp(boxesData[row][col][anchor][3]) * this.config.anchors[anchor].y) / numCells) * correctionFactorY;\r\n            const x = (ctX - (widthLocal / 2));\r\n            const y = (ctY - (heightLocal / 2));\r\n            const pos = { row, col, anchor };\r\n            const { classScore, label } = this.withClassScores\r\n              ? await this.extractPredictedClass(classScoresTensor as tf.Tensor4D, pos)\r\n              : { classScore: 1, label: 0 };\r\n            results.push({\r\n              box: new BoundingBox(x, y, x + widthLocal, y + heightLocal),\r\n              score,\r\n              classScore: score * classScore,\r\n              label,\r\n              ...pos,\r\n            });\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n    boxesTensor.dispose();\r\n    scoresTensor.dispose();\r\n    classScoresTensor.dispose();\r\n    return results;\r\n  }\r\n\r\n  private async extractPredictedClass(classesTensor: tf.Tensor4D, pos: { row: number, col: number, anchor: number }) {\r\n    const { row, col, anchor } = pos;\r\n    const classesData = await classesTensor.array();\r\n    return Array(this.config.classes.length).fill(0)\r\n      .map((_, i) => classesData[row][col][anchor][i])\r\n      .map((classScore, label) => ({\r\n        classScore,\r\n        label,\r\n      }))\r\n      .reduce((max, curr) => (max.classScore > curr.classScore ? max : curr));\r\n  }\r\n}\r\n", "import { Point } from '../classes/Point';\r\n\r\nexport type TinyYolov2Config = {\r\n  withSeparableConvs: boolean\r\n  iouThreshold: number\r\n  anchors: Point[]\r\n  classes: string[]\r\n  meanRgb?: [number, number, number]\r\n  withClassScores?: boolean,\r\n  filterSizes?: number[]\r\n  isFirstLayerConv2d?: boolean\r\n}\r\n\r\nconst isNumber = (arg: any) => typeof arg === 'number';\r\n\r\nexport function validateConfig(config: any) {\r\n  if (!config) {\r\n    throw new Error(`invalid config: ${config}`);\r\n  }\r\n\r\n  if (typeof config.withSeparableConvs !== 'boolean') {\r\n    throw new Error(`config.withSeparableConvs has to be a boolean, have: ${config.withSeparableConvs}`);\r\n  }\r\n\r\n  if (!isNumber(config.iouThreshold) || config.iouThreshold < 0 || config.iouThreshold > 1.0) {\r\n    throw new Error(`config.iouThreshold has to be a number between [0, 1], have: ${config.iouThreshold}`);\r\n  }\r\n\r\n  if (\r\n    !Array.isArray(config.classes)\r\n    || !config.classes.length\r\n    || !config.classes.every((c: any) => typeof c === 'string')\r\n  ) {\r\n    throw new Error(`config.classes has to be an array class names: string[], have: ${JSON.stringify(config.classes)}`);\r\n  }\r\n\r\n  if (\r\n    !Array.isArray(config.anchors)\r\n    || !config.anchors.length\r\n    || !config.anchors.map((a: any) => a || {}).every((a: any) => isNumber(a.x) && isNumber(a.y))\r\n  ) {\r\n    throw new Error(`config.anchors has to be an array of { x: number, y: number }, have: ${JSON.stringify(config.anchors)}`);\r\n  }\r\n\r\n  if (config.meanRgb && (\r\n    !Array.isArray(config.meanRgb)\r\n    || config.meanRgb.length !== 3\r\n    || !config.meanRgb.every(isNumber)\r\n  )) {\r\n    throw new Error(`config.meanRgb has to be an array of shape [number, number, number], have: ${JSON.stringify(config.meanRgb)}`);\r\n  }\r\n}\r\n", "import * as tf from '../../dist/tfjs.esm';\r\n\r\nimport { leaky } from './leaky';\r\nimport { ConvWithBatchNorm } from './types';\r\n\r\nexport function convWithBatchNorm(x: tf.Tensor4D, params: ConvWithBatchNorm): tf.Tensor4D {\r\n  return tf.tidy(() => {\r\n    let out = tf.pad(x, [[0, 0], [1, 1], [1, 1], [0, 0]]) as tf.Tensor4D;\r\n    out = tf.conv2d(out, params.conv.filters, [1, 1], 'valid');\r\n    out = tf.sub(out, params.bn.sub);\r\n    out = tf.mul(out, params.bn.truediv);\r\n    out = tf.add(out, params.conv.bias);\r\n    return leaky(out);\r\n  });\r\n}\r\n", "import * as tf from '../../dist/tfjs.esm';\r\n\r\nexport function leaky(x: tf.Tensor4D): tf.Tensor4D {\r\n  return tf.tidy(() => {\r\n    const min = tf.mul(x, tf.scalar(0.10000000149011612));\r\n    return tf.add(tf.relu(tf.sub(x, min)), min);\r\n  });\r\n}\r\n", "import * as tf from '../../dist/tfjs.esm';\r\n\r\nimport { SeparableConvParams } from '../common/types';\r\nimport { leaky } from './leaky';\r\n\r\nexport function depthwiseSeparableConv(x: tf.Tensor4D, params: SeparableConvParams): tf.Tensor4D {\r\n  return tf.tidy(() => {\r\n    let out = tf.pad(x, [[0, 0], [1, 1], [1, 1], [0, 0]]) as tf.Tensor4D;\r\n    out = tf.separableConv2d(out, params.depthwise_filter, params.pointwise_filter, [1, 1], 'valid');\r\n    out = tf.add(out, params.bias);\r\n    return leaky(out);\r\n  });\r\n}\r\n", "import * as tf from '../../dist/tfjs.esm';\r\n\r\nimport { extractConvParamsFactory } from '../common/index';\r\nimport { extractSeparableConvParamsFactory } from '../common/extractSeparableConvParamsFactory';\r\nimport { extractWeightsFactory } from '../common/extractWeightsFactory';\r\nimport { ExtractWeightsFunction, ParamMapping } from '../common/types';\r\nimport { TinyYolov2Config } from './config';\r\nimport { BatchNorm, ConvWithBatchNorm, TinyYolov2NetParams } from './types';\r\n\r\nfunction extractorsFactory(extractWeights: ExtractWeightsFunction, paramMappings: ParamMapping[]) {\r\n  const extractConvParams = extractConvParamsFactory(extractWeights, paramMappings);\r\n\r\n  function extractBatchNormParams(size: number, mappedPrefix: string): BatchNorm {\r\n    const sub = tf.tensor1d(extractWeights(size));\r\n    const truediv = tf.tensor1d(extractWeights(size));\r\n\r\n    paramMappings.push(\r\n      { paramPath: `${mappedPrefix}/sub` },\r\n      { paramPath: `${mappedPrefix}/truediv` },\r\n    );\r\n    return { sub, truediv };\r\n  }\r\n\r\n  function extractConvWithBatchNormParams(channelsIn: number, channelsOut: number, mappedPrefix: string): ConvWithBatchNorm {\r\n    const conv = extractConvParams(channelsIn, channelsOut, 3, `${mappedPrefix}/conv`);\r\n    const bn = extractBatchNormParams(channelsOut, `${mappedPrefix}/bn`);\r\n    return { conv, bn };\r\n  }\r\n  const extractSeparableConvParams = extractSeparableConvParamsFactory(extractWeights, paramMappings);\r\n\r\n  return {\r\n    extractConvParams,\r\n    extractConvWithBatchNormParams,\r\n    extractSeparableConvParams,\r\n  };\r\n}\r\n\r\nexport function extractParams(\r\n  weights: Float32Array,\r\n  config: TinyYolov2Config,\r\n  boxEncodingSize: number,\r\n  filterSizes: number[],\r\n): { params: TinyYolov2NetParams, paramMappings: ParamMapping[] } {\r\n  const {\r\n    extractWeights,\r\n    getRemainingWeights,\r\n  } = extractWeightsFactory(weights);\r\n\r\n  const paramMappings: ParamMapping[] = [];\r\n  const {\r\n    extractConvParams,\r\n    extractConvWithBatchNormParams,\r\n    extractSeparableConvParams,\r\n  } = extractorsFactory(extractWeights, paramMappings);\r\n  let params: TinyYolov2NetParams;\r\n\r\n  if (config.withSeparableConvs) {\r\n    const [s0, s1, s2, s3, s4, s5, s6, s7, s8] = filterSizes;\r\n    const conv0 = config.isFirstLayerConv2d\r\n      ? extractConvParams(s0, s1, 3, 'conv0')\r\n      : extractSeparableConvParams(s0, s1, 'conv0');\r\n    const conv1 = extractSeparableConvParams(s1, s2, 'conv1');\r\n    const conv2 = extractSeparableConvParams(s2, s3, 'conv2');\r\n    const conv3 = extractSeparableConvParams(s3, s4, 'conv3');\r\n    const conv4 = extractSeparableConvParams(s4, s5, 'conv4');\r\n    const conv5 = extractSeparableConvParams(s5, s6, 'conv5');\r\n    const conv6 = s7 ? extractSeparableConvParams(s6, s7, 'conv6') : undefined;\r\n    const conv7 = s8 ? extractSeparableConvParams(s7, s8, 'conv7') : undefined;\r\n    const conv8 = extractConvParams(s8 || s7 || s6, 5 * boxEncodingSize, 1, 'conv8');\r\n    params = {\r\n      conv0, conv1, conv2, conv3, conv4, conv5, conv6, conv7, conv8,\r\n    };\r\n  } else {\r\n    const [s0, s1, s2, s3, s4, s5, s6, s7, s8] = filterSizes;\r\n    const conv0 = extractConvWithBatchNormParams(s0, s1, 'conv0');\r\n    const conv1 = extractConvWithBatchNormParams(s1, s2, 'conv1');\r\n    const conv2 = extractConvWithBatchNormParams(s2, s3, 'conv2');\r\n    const conv3 = extractConvWithBatchNormParams(s3, s4, 'conv3');\r\n    const conv4 = extractConvWithBatchNormParams(s4, s5, 'conv4');\r\n    const conv5 = extractConvWithBatchNormParams(s5, s6, 'conv5');\r\n    const conv6 = extractConvWithBatchNormParams(s6, s7, 'conv6');\r\n    const conv7 = extractConvWithBatchNormParams(s7, s8, 'conv7');\r\n    const conv8 = extractConvParams(s8, 5 * boxEncodingSize, 1, 'conv8');\r\n    params = {\r\n      conv0, conv1, conv2, conv3, conv4, conv5, conv6, conv7, conv8,\r\n    };\r\n  }\r\n  if (getRemainingWeights().length !== 0) {\r\n    throw new Error(`weights remaing after extract: ${getRemainingWeights().length}`);\r\n  }\r\n  return { params, paramMappings };\r\n}\r\n", "import * as tf from '../../dist/tfjs.esm';\r\n\r\nimport { ConvParams } from '../common/index';\r\nimport { disposeUnusedWeightTensors } from '../common/disposeUnusedWeightTensors';\r\nimport { loadSeparableConvParamsFactory } from '../common/extractSeparableConvParamsFactory';\r\nimport { extractWeightEntryFactory } from '../common/extractWeightEntryFactory';\r\nimport { ParamMapping } from '../common/types';\r\nimport { TinyYolov2Config } from './config';\r\nimport { BatchNorm, ConvWithBatchNorm, TinyYolov2NetParams } from './types';\r\n\r\nfunction extractorsFactory(weightMap: any, paramMappings: ParamMapping[]) {\r\n  const extractWeightEntry = extractWeightEntryFactory(weightMap, paramMappings);\r\n\r\n  function extractBatchNormParams(prefix: string): BatchNorm {\r\n    const sub = extractWeightEntry(`${prefix}/sub`, 1);\r\n    const truediv = extractWeightEntry(`${prefix}/truediv`, 1);\r\n    return { sub, truediv };\r\n  }\r\n\r\n  function extractConvParams(prefix: string): ConvParams {\r\n    const filters = extractWeightEntry(`${prefix}/filters`, 4);\r\n    const bias = extractWeightEntry(`${prefix}/bias`, 1);\r\n    return { filters, bias };\r\n  }\r\n\r\n  function extractConvWithBatchNormParams(prefix: string): ConvWithBatchNorm {\r\n    const conv = extractConvParams(`${prefix}/conv`);\r\n    const bn = extractBatchNormParams(`${prefix}/bn`);\r\n    return { conv, bn };\r\n  }\r\n\r\n  const extractSeparableConvParams = loadSeparableConvParamsFactory(extractWeightEntry);\r\n  return {\r\n    extractConvParams,\r\n    extractConvWithBatchNormParams,\r\n    extractSeparableConvParams,\r\n  };\r\n}\r\n\r\nexport function extractParamsFromWeightMap(\r\n  weightMap: tf.NamedTensorMap,\r\n  config: TinyYolov2Config,\r\n): { params: TinyYolov2NetParams, paramMappings: ParamMapping[] } {\r\n  const paramMappings: ParamMapping[] = [];\r\n\r\n  const {\r\n    extractConvParams,\r\n    extractConvWithBatchNormParams,\r\n    extractSeparableConvParams,\r\n  } = extractorsFactory(weightMap, paramMappings);\r\n\r\n  let params: TinyYolov2NetParams;\r\n\r\n  if (config.withSeparableConvs) {\r\n    // eslint-disable-next-line no-mixed-operators\r\n    const numFilters = (config.filterSizes && config.filterSizes.length || 9);\r\n    params = {\r\n      conv0: config.isFirstLayerConv2d ? extractConvParams('conv0') : extractSeparableConvParams('conv0'),\r\n      conv1: extractSeparableConvParams('conv1'),\r\n      conv2: extractSeparableConvParams('conv2'),\r\n      conv3: extractSeparableConvParams('conv3'),\r\n      conv4: extractSeparableConvParams('conv4'),\r\n      conv5: extractSeparableConvParams('conv5'),\r\n      conv6: numFilters > 7 ? extractSeparableConvParams('conv6') : undefined,\r\n      conv7: numFilters > 8 ? extractSeparableConvParams('conv7') : undefined,\r\n      conv8: extractConvParams('conv8'),\r\n    };\r\n  } else {\r\n    params = {\r\n      conv0: extractConvWithBatchNormParams('conv0'),\r\n      conv1: extractConvWithBatchNormParams('conv1'),\r\n      conv2: extractConvWithBatchNormParams('conv2'),\r\n      conv3: extractConvWithBatchNormParams('conv3'),\r\n      conv4: extractConvWithBatchNormParams('conv4'),\r\n      conv5: extractConvWithBatchNormParams('conv5'),\r\n      conv6: extractConvWithBatchNormParams('conv6'),\r\n      conv7: extractConvWithBatchNormParams('conv7'),\r\n      conv8: extractConvParams('conv8'),\r\n    };\r\n  }\r\n\r\n  disposeUnusedWeightTensors(weightMap, paramMappings);\r\n  return { params, paramMappings };\r\n}\r\n", "export interface ITinyYolov2Options {\r\n  inputSize?: number\r\n  scoreThreshold?: number\r\n}\r\n\r\nexport class TinyYolov2Options {\r\n  protected _name: string = 'TinyYolov2Options'\r\n\r\n  private _inputSize: number\r\n\r\n  private _scoreThreshold: number\r\n\r\n  constructor({ inputSize, scoreThreshold }: ITinyYolov2Options = {}) {\r\n    this._inputSize = inputSize || 416;\r\n    this._scoreThreshold = scoreThreshold || 0.5;\r\n\r\n    if (typeof this._inputSize !== 'number' || this._inputSize % 32 !== 0) {\r\n      throw new Error(`${this._name} - expected inputSize to be a number divisible by 32`);\r\n    }\r\n\r\n    if (typeof this._scoreThreshold !== 'number' || this._scoreThreshold <= 0 || this._scoreThreshold >= 1) {\r\n      throw new Error(`${this._name} - expected scoreThreshold to be a number between 0 and 1`);\r\n    }\r\n  }\r\n\r\n  get inputSize(): number { return this._inputSize; }\r\n\r\n  get scoreThreshold(): number { return this._scoreThreshold; }\r\n}\r\n", "import * as tf from '../../dist/tfjs.esm';\r\n\r\nimport { FaceDetection, Point } from '../classes/index';\r\nimport { ParamMapping } from '../common/types';\r\nimport { TNetInput } from '../dom/types';\r\nimport {\r\n  BOX_ANCHORS,\r\n  BOX_ANCHORS_SEPARABLE,\r\n  DEFAULT_MODEL_NAME,\r\n  DEFAULT_MODEL_NAME_SEPARABLE_CONV,\r\n  IOU_THRESHOLD,\r\n  MEAN_RGB_SEPARABLE,\r\n} from './const';\r\nimport { TinyYolov2Base } from './TinyYolov2Base';\r\nimport { ITinyYolov2Options } from './TinyYolov2Options';\r\nimport { TinyYolov2NetParams } from './types';\r\n\r\nexport class TinyYolov2 extends TinyYolov2Base {\r\n  constructor(withSeparableConvs: boolean = true) {\r\n    const config = {\r\n      withSeparableConvs,\r\n      iouThreshold: IOU_THRESHOLD,\r\n      classes: ['face'],\r\n      ...(withSeparableConvs\r\n        ? {\r\n          anchors: BOX_ANCHORS_SEPARABLE,\r\n          meanRgb: MEAN_RGB_SEPARABLE,\r\n        }\r\n        : {\r\n          anchors: BOX_ANCHORS,\r\n          withClassScores: true,\r\n        }),\r\n    };\r\n\r\n    super(config);\r\n  }\r\n\r\n  public get withSeparableConvs(): boolean {\r\n    return this.config.withSeparableConvs;\r\n  }\r\n\r\n  public get anchors(): Point[] {\r\n    return this.config.anchors;\r\n  }\r\n\r\n  public async locateFaces(input: TNetInput, forwardParams: ITinyYolov2Options): Promise<FaceDetection[]> {\r\n    const objectDetections = await this.detect(input, forwardParams);\r\n    return objectDetections.map((det) => new FaceDetection(det.score, det.relativeBox, { width: det.imageWidth, height: det.imageHeight }));\r\n  }\r\n\r\n  protected getDefaultModelName(): string {\r\n    return this.withSeparableConvs ? DEFAULT_MODEL_NAME_SEPARABLE_CONV : DEFAULT_MODEL_NAME;\r\n  }\r\n\r\n  protected extractParamsFromWeightMap(weightMap: tf.NamedTensorMap): { params: TinyYolov2NetParams, paramMappings: ParamMapping[] } {\r\n    return super.extractParamsFromWeightMap(weightMap);\r\n  }\r\n}\r\n", "import { TinyYolov2 } from './TinyYolov2';\r\n\r\nexport * from './TinyYolov2Options';\r\nexport * from './config';\r\nexport * from './types';\r\nexport { TinyYolov2 };\r\n\r\nexport function createTinyYolov2(weights: Float32Array, withSeparableConvs: boolean = true) {\r\n  const net = new TinyYolov2(withSeparableConvs);\r\n  net.extractWeights(weights);\r\n  return net;\r\n}\r\n", "import { ITinyYolov2Options, TinyYolov2Options } from '../tinyYolov2/index';\r\n\r\nexport interface ITinyFaceDetectorOptions extends ITinyYolov2Options {}\r\n\r\nexport class TinyFaceDetectorOptions extends TinyYolov2Options {\r\n  protected _name: string = 'TinyFaceDetectorOptions'\r\n}\r\n", "export class ComposableTask<T> {\r\n  public async then(\r\n    // eslint-disable-next-line no-unused-vars\r\n    onfulfilled: (value: T) => T | PromiseLike<T>,\r\n  ): Promise<T> {\r\n    return onfulfilled(await this.run());\r\n  }\r\n\r\n  public async run(): Promise<T> {\r\n    throw new Error('ComposableTask - run is not implemented');\r\n  }\r\n}\r\n", "/* eslint-disable max-classes-per-file */\r\nimport * as tf from '../../dist/tfjs.esm';\r\n\r\nimport { FaceLandmarks68 } from '../classes/FaceLandmarks68';\r\nimport { extractFaces, extractFaceTensors, TNetInput } from '../dom/index';\r\nimport { FaceLandmark68Net } from '../faceLandmarkNet/FaceLandmark68Net';\r\nimport { FaceLandmark68TinyNet } from '../faceLandmarkNet/FaceLandmark68TinyNet';\r\nimport { WithFaceDetection } from '../factories/WithFaceDetection';\r\nimport { extendWithFaceLandmarks, WithFaceLandmarks } from '../factories/WithFaceLandmarks';\r\nimport { ComposableTask } from './ComposableTask';\r\nimport { ComputeAllFaceDescriptorsTask, ComputeSingleFaceDescriptorTask } from './ComputeFaceDescriptorsTasks';\r\nimport { nets } from './nets';\r\nimport {\r\n  PredictAllAgeAndGenderWithFaceAlignmentTask,\r\n  PredictSingleAgeAndGenderWithFaceAlignmentTask,\r\n} from './PredictAgeAndGenderTask';\r\nimport {\r\n  PredictAllFaceExpressionsWithFaceAlignmentTask,\r\n  PredictSingleFaceExpressionsWithFaceAlignmentTask,\r\n} from './PredictFaceExpressionsTask';\r\n\r\nexport class DetectFaceLandmarksTaskBase<TReturn, TParentReturn> extends ComposableTask<TReturn> {\r\n  constructor(\r\n    // eslint-disable-next-line no-unused-vars\r\n    protected parentTask: ComposableTask<TParentReturn> | Promise<TParentReturn>,\r\n    // eslint-disable-next-line no-unused-vars\r\n    protected input: TNetInput,\r\n    // eslint-disable-next-line no-unused-vars\r\n    protected useTinyLandmarkNet: boolean,\r\n  ) {\r\n    super();\r\n  }\r\n\r\n  protected get landmarkNet(): FaceLandmark68Net | FaceLandmark68TinyNet {\r\n    return this.useTinyLandmarkNet\r\n      ? nets.faceLandmark68TinyNet\r\n      : nets.faceLandmark68Net;\r\n  }\r\n}\r\n\r\nexport class DetectAllFaceLandmarksTask<\r\n  TSource extends WithFaceDetection<{}>\r\n> extends DetectFaceLandmarksTaskBase<WithFaceLandmarks<TSource>[], TSource[]> {\r\n  public async run(): Promise<WithFaceLandmarks<TSource>[]> {\r\n    const parentResults = await this.parentTask;\r\n    const detections = parentResults.map((res) => res.detection);\r\n\r\n    const faces: Array<HTMLCanvasElement | tf.Tensor3D> = this.input instanceof tf.Tensor\r\n      ? await extractFaceTensors(this.input, detections)\r\n      : await extractFaces(this.input, detections);\r\n\r\n    const faceLandmarksByFace = await Promise.all(faces.map(\r\n      (face) => this.landmarkNet.detectLandmarks(face),\r\n    )) as FaceLandmarks68[];\r\n\r\n    faces.forEach((f) => f instanceof tf.Tensor && f.dispose());\r\n\r\n    return parentResults.map((parentResult, i) => extendWithFaceLandmarks<TSource>(parentResult, faceLandmarksByFace[i]));\r\n  }\r\n\r\n  withFaceExpressions() {\r\n    return new PredictAllFaceExpressionsWithFaceAlignmentTask(this, this.input);\r\n  }\r\n\r\n  withAgeAndGender() {\r\n    return new PredictAllAgeAndGenderWithFaceAlignmentTask(this, this.input);\r\n  }\r\n\r\n  withFaceDescriptors() {\r\n    return new ComputeAllFaceDescriptorsTask(this, this.input);\r\n  }\r\n}\r\n\r\nexport class DetectSingleFaceLandmarksTask<\r\n  TSource extends WithFaceDetection<{}>\r\n> extends DetectFaceLandmarksTaskBase<WithFaceLandmarks<TSource> | undefined, TSource | undefined> {\r\n  public async run(): Promise<WithFaceLandmarks<TSource> | undefined> {\r\n    const parentResult = await this.parentTask;\r\n    if (!parentResult) {\r\n      return undefined;\r\n    }\r\n\r\n    const { detection } = parentResult;\r\n    const faces: Array<HTMLCanvasElement | tf.Tensor3D> = this.input instanceof tf.Tensor\r\n      ? await extractFaceTensors(this.input, [detection])\r\n      : await extractFaces(this.input, [detection]);\r\n\r\n    const landmarks = await this.landmarkNet.detectLandmarks(faces[0]) as FaceLandmarks68;\r\n\r\n    faces.forEach((f) => f instanceof tf.Tensor && f.dispose());\r\n\r\n    return extendWithFaceLandmarks<TSource>(parentResult, landmarks);\r\n  }\r\n\r\n  withFaceExpressions() {\r\n    return new PredictSingleFaceExpressionsWithFaceAlignmentTask(this, this.input);\r\n  }\r\n\r\n  withAgeAndGender() {\r\n    return new PredictSingleAgeAndGenderWithFaceAlignmentTask(this, this.input);\r\n  }\r\n\r\n  withFaceDescriptor() {\r\n    return new ComputeSingleFaceDescriptorTask(this, this.input);\r\n  }\r\n}\r\n", "import * as tf from '../../dist/tfjs.esm';\r\n\r\nimport { FaceDetection } from '../classes/FaceDetection';\r\nimport { extractFaces, extractFaceTensors, TNetInput } from '../dom/index';\r\nimport { WithFaceDetection } from '../factories/WithFaceDetection';\r\nimport { isWithFaceLandmarks, WithFaceLandmarks } from '../factories/WithFaceLandmarks';\r\n\r\nexport async function extractAllFacesAndComputeResults<TSource extends WithFaceDetection<{}>, TResult>(\r\n  parentResults: TSource[],\r\n  input: TNetInput,\r\n  // eslint-disable-next-line no-unused-vars\r\n  computeResults: (faces: Array<HTMLCanvasElement | tf.Tensor3D>) => Promise<TResult>,\r\n  extractedFaces?: Array<HTMLCanvasElement | tf.Tensor3D> | null,\r\n  // eslint-disable-next-line no-unused-vars\r\n  getRectForAlignment: (parentResult: WithFaceLandmarks<TSource, any>) => FaceDetection = ({ alignedRect }) => alignedRect,\r\n) {\r\n  const faceBoxes = parentResults.map((parentResult) => (isWithFaceLandmarks(parentResult)\r\n    ? getRectForAlignment(parentResult)\r\n    : parentResult.detection));\r\n  const faces: Array<HTMLCanvasElement | tf.Tensor3D> = extractedFaces || (\r\n    input instanceof tf.Tensor\r\n      ? await extractFaceTensors(input, faceBoxes)\r\n      : await extractFaces(input, faceBoxes)\r\n  );\r\n\r\n  const results = await computeResults(faces);\r\n\r\n  faces.forEach((f) => f instanceof tf.Tensor && f.dispose());\r\n\r\n  return results;\r\n}\r\n\r\nexport async function extractSingleFaceAndComputeResult<TSource extends WithFaceDetection<{}>, TResult>(\r\n  parentResult: TSource,\r\n  input: TNetInput,\r\n  // eslint-disable-next-line no-unused-vars\r\n  computeResult: (face: HTMLCanvasElement | tf.Tensor3D) => Promise<TResult>,\r\n  extractedFaces?: Array<HTMLCanvasElement | tf.Tensor3D> | null,\r\n  // eslint-disable-next-line no-unused-vars\r\n  getRectForAlignment?: (parentResultLocal: WithFaceLandmarks<TSource, any>) => FaceDetection,\r\n) {\r\n  return extractAllFacesAndComputeResults<TSource, TResult>(\r\n    [parentResult],\r\n    input,\r\n    async (faces) => computeResult(faces[0]),\r\n    extractedFaces,\r\n    getRectForAlignment,\r\n  );\r\n}\r\n", "import { Point } from '../classes/index';\r\n\r\nexport const IOU_THRESHOLD = 0.4;\r\n\r\nexport const BOX_ANCHORS = [\r\n  new Point(1.603231, 2.094468),\r\n  new Point(6.041143, 7.080126),\r\n  new Point(2.882459, 3.518061),\r\n  new Point(4.266906, 5.178857),\r\n  new Point(9.041765, 10.66308),\r\n];\r\n\r\nexport const MEAN_RGB: [number, number, number] = [117.001, 114.697, 97.404];\r\n", "import * as tf from '../../dist/tfjs.esm';\r\n\r\nimport { FaceDetection, Point } from '../classes/index';\r\nimport { ParamMapping } from '../common/index';\r\nimport { TNetInput } from '../dom/index';\r\nimport { ITinyYolov2Options } from '../tinyYolov2/index';\r\nimport { TinyYolov2Base } from '../tinyYolov2/TinyYolov2Base';\r\nimport { TinyYolov2NetParams } from '../tinyYolov2/types';\r\nimport { BOX_ANCHORS, IOU_THRESHOLD, MEAN_RGB } from './const';\r\n\r\nexport class TinyFaceDetector extends TinyYolov2Base {\r\n  constructor() {\r\n    const config = {\r\n      withSeparableConvs: true,\r\n      iouThreshold: IOU_THRESHOLD,\r\n      classes: ['face'],\r\n      anchors: BOX_ANCHORS,\r\n      meanRgb: MEAN_RGB,\r\n      isFirstLayerConv2d: true,\r\n      filterSizes: [3, 16, 32, 64, 128, 256, 512],\r\n    };\r\n\r\n    super(config);\r\n  }\r\n\r\n  public get anchors(): Point[] {\r\n    return this.config.anchors;\r\n  }\r\n\r\n  public async locateFaces(input: TNetInput, forwardParams: ITinyYolov2Options): Promise<FaceDetection[]> {\r\n    const objectDetections = await this.detect(input, forwardParams);\r\n    return objectDetections.map((det) => new FaceDetection(det.score, det.relativeBox, { width: det.imageWidth, height: det.imageHeight }));\r\n  }\r\n\r\n  protected getDefaultModelName(): string {\r\n    return 'tiny_face_detector_model';\r\n  }\r\n\r\n  protected extractParamsFromWeightMap(weightMap: tf.NamedTensorMap): { params: TinyYolov2NetParams, paramMappings: ParamMapping[] } {\r\n    return super.extractParamsFromWeightMap(weightMap);\r\n  }\r\n}\r\n", "import { AgeGenderNet } from '../ageGenderNet/AgeGenderNet';\r\nimport { AgeAndGenderPrediction } from '../ageGenderNet/types';\r\nimport { FaceDetection } from '../classes/FaceDetection';\r\nimport { FaceLandmarks68 } from '../classes/FaceLandmarks68';\r\nimport { TNetInput } from '../dom/index';\r\nimport { FaceExpressionNet } from '../faceExpressionNet/FaceExpressionNet';\r\nimport { FaceExpressions } from '../faceExpressionNet/FaceExpressions';\r\nimport { FaceLandmark68Net } from '../faceLandmarkNet/FaceLandmark68Net';\r\nimport { FaceLandmark68TinyNet } from '../faceLandmarkNet/FaceLandmark68TinyNet';\r\nimport { FaceRecognitionNet } from '../faceRecognitionNet/FaceRecognitionNet';\r\nimport { SsdMobilenetv1 } from '../ssdMobilenetv1/SsdMobilenetv1';\r\nimport { SsdMobilenetv1Options } from '../ssdMobilenetv1/SsdMobilenetv1Options';\r\nimport { TinyFaceDetector } from '../tinyFaceDetector/TinyFaceDetector';\r\nimport { TinyFaceDetectorOptions } from '../tinyFaceDetector/TinyFaceDetectorOptions';\r\nimport { ITinyYolov2Options, TinyYolov2 } from '../tinyYolov2/index';\r\n\r\nexport const nets = {\r\n  ssdMobilenetv1: new SsdMobilenetv1(),\r\n  tinyFaceDetector: new TinyFaceDetector(),\r\n  tinyYolov2: new TinyYolov2(),\r\n  faceLandmark68Net: new FaceLandmark68Net(),\r\n  faceLandmark68TinyNet: new FaceLandmark68TinyNet(),\r\n  faceRecognitionNet: new FaceRecognitionNet(),\r\n  faceExpressionNet: new FaceExpressionNet(),\r\n  ageGenderNet: new AgeGenderNet(),\r\n};\r\n\r\n/**\r\n * Attempts to detect all faces in an image using SSD Mobilenetv1 Network.\r\n *\r\n * @param input The input image.\r\n * @param options (optional, default: see SsdMobilenetv1Options constructor for default parameters).\r\n * @returns Bounding box of each face with score.\r\n */\r\nexport const ssdMobilenetv1 = (input: TNetInput, options: SsdMobilenetv1Options): Promise<FaceDetection[]> => nets.ssdMobilenetv1.locateFaces(input, options);\r\n\r\n/**\r\n * Attempts to detect all faces in an image using the Tiny Face Detector.\r\n *\r\n * @param input The input image.\r\n * @param options (optional, default: see TinyFaceDetectorOptions constructor for default parameters).\r\n * @returns Bounding box of each face with score.\r\n */\r\nexport const tinyFaceDetector = (input: TNetInput, options: TinyFaceDetectorOptions): Promise<FaceDetection[]> => nets.tinyFaceDetector.locateFaces(input, options);\r\n\r\n/**\r\n * Attempts to detect all faces in an image using the Tiny Yolov2 Network.\r\n *\r\n * @param input The input image.\r\n * @param options (optional, default: see TinyYolov2Options constructor for default parameters).\r\n * @returns Bounding box of each face with score.\r\n */\r\nexport const tinyYolov2 = (input: TNetInput, options: ITinyYolov2Options): Promise<FaceDetection[]> => nets.tinyYolov2.locateFaces(input, options);\r\n\r\n/**\r\n * Detects the 68 point face landmark positions of the face shown in an image.\r\n *\r\n * @param inputs The face image extracted from the bounding box of a face. Can\r\n * also be an array of input images, which will be batch processed.\r\n * @returns 68 point face landmarks or array thereof in case of batch input.\r\n */\r\nexport const detectFaceLandmarks = (input: TNetInput): Promise<FaceLandmarks68 | FaceLandmarks68[]> => nets.faceLandmark68Net.detectLandmarks(input);\r\n\r\n/**\r\n * Detects the 68 point face landmark positions of the face shown in an image\r\n * using a tinier version of the 68 point face landmark model, which is slightly\r\n * faster at inference, but also slightly less accurate.\r\n *\r\n * @param inputs The face image extracted from the bounding box of a face. Can\r\n * also be an array of input images, which will be batch processed.\r\n * @returns 68 point face landmarks or array thereof in case of batch input.\r\n */\r\nexport const detectFaceLandmarksTiny = (input: TNetInput): Promise<FaceLandmarks68 | FaceLandmarks68[]> => nets.faceLandmark68TinyNet.detectLandmarks(input);\r\n\r\n/**\r\n * Computes a 128 entry vector (face descriptor / face embeddings) from the face shown in an image,\r\n * which uniquely represents the features of that persons face. The computed face descriptor can\r\n * be used to measure the similarity between faces, by computing the euclidean distance of two\r\n * face descriptors.\r\n *\r\n * @param inputs The face image extracted from the aligned bounding box of a face. Can\r\n * also be an array of input images, which will be batch processed.\r\n * @returns Face descriptor with 128 entries or array thereof in case of batch input.\r\n */\r\nexport const computeFaceDescriptor = (input: TNetInput): Promise<Float32Array | Float32Array[]> => nets.faceRecognitionNet.computeFaceDescriptor(input);\r\n\r\n/**\r\n * Recognizes the facial expressions from a face image.\r\n *\r\n * @param inputs The face image extracted from the bounding box of a face. Can\r\n * also be an array of input images, which will be batch processed.\r\n * @returns Facial expressions with corresponding probabilities or array thereof in case of batch input.\r\n */\r\nexport const recognizeFaceExpressions = (input: TNetInput): Promise<FaceExpressions | FaceExpressions[]> => nets.faceExpressionNet.predictExpressions(input);\r\n\r\n/**\r\n * Predicts age and gender from a face image.\r\n *\r\n * @param inputs The face image extracted from the bounding box of a face. Can\r\n * also be an array of input images, which will be batch processed.\r\n * @returns Predictions with age, gender and gender probability or array thereof in case of batch input.\r\n */\r\nexport const predictAgeAndGender = (input: TNetInput): Promise<AgeAndGenderPrediction | AgeAndGenderPrediction[]> => nets.ageGenderNet.predictAgeAndGender(input);\r\n\r\nexport const loadSsdMobilenetv1Model = (url: string) => nets.ssdMobilenetv1.load(url);\r\nexport const loadTinyFaceDetectorModel = (url: string) => nets.tinyFaceDetector.load(url);\r\nexport const loadTinyYolov2Model = (url: string) => nets.tinyYolov2.load(url);\r\nexport const loadFaceLandmarkModel = (url: string) => nets.faceLandmark68Net.load(url);\r\nexport const loadFaceLandmarkTinyModel = (url: string) => nets.faceLandmark68TinyNet.load(url);\r\nexport const loadFaceRecognitionModel = (url: string) => nets.faceRecognitionNet.load(url);\r\nexport const loadFaceExpressionModel = (url: string) => nets.faceExpressionNet.load(url);\r\nexport const loadAgeGenderModel = (url: string) => nets.ageGenderNet.load(url);\r\n\r\n// backward compatibility\r\nexport const loadFaceDetectionModel = loadSsdMobilenetv1Model;\r\nexport const locateFaces = ssdMobilenetv1;\r\nexport const detectLandmarks = detectFaceLandmarks;\r\n", "/* eslint-disable max-classes-per-file */\r\nimport * as tf from '../../dist/tfjs.esm';\r\n\r\nimport { TNetInput } from '../dom/index';\r\nimport { FaceExpressions } from '../faceExpressionNet/FaceExpressions';\r\nimport { WithFaceDetection } from '../factories/WithFaceDetection';\r\nimport { extendWithFaceExpressions, WithFaceExpressions } from '../factories/WithFaceExpressions';\r\nimport { WithFaceLandmarks } from '../factories/WithFaceLandmarks';\r\nimport { ComposableTask } from './ComposableTask';\r\nimport { ComputeAllFaceDescriptorsTask, ComputeSingleFaceDescriptorTask } from './ComputeFaceDescriptorsTasks';\r\nimport { extractAllFacesAndComputeResults, extractSingleFaceAndComputeResult } from './extractFacesAndComputeResults';\r\nimport { nets } from './nets';\r\nimport {\r\n  PredictAllAgeAndGenderTask,\r\n  PredictAllAgeAndGenderWithFaceAlignmentTask,\r\n  PredictSingleAgeAndGenderTask,\r\n  PredictSingleAgeAndGenderWithFaceAlignmentTask,\r\n} from './PredictAgeAndGenderTask';\r\n\r\nexport class PredictFaceExpressionsTaskBase<TReturn, TParentReturn> extends ComposableTask<TReturn> {\r\n  constructor(\r\n    // eslint-disable-next-line no-unused-vars\r\n    protected parentTask: ComposableTask<TParentReturn> | Promise<TParentReturn>,\r\n    // eslint-disable-next-line no-unused-vars\r\n    protected input: TNetInput,\r\n    // eslint-disable-next-line no-unused-vars\r\n    protected extractedFaces?: Array<HTMLCanvasElement | tf.Tensor3D>,\r\n  ) {\r\n    super();\r\n  }\r\n}\r\n\r\nexport class PredictAllFaceExpressionsTask<\r\n  TSource extends WithFaceDetection<{}>\r\n> extends PredictFaceExpressionsTaskBase<WithFaceExpressions<TSource>[], TSource[]> {\r\n  public async run(): Promise<WithFaceExpressions<TSource>[]> {\r\n    const parentResults = await this.parentTask;\r\n\r\n    const faceExpressionsByFace = await extractAllFacesAndComputeResults<TSource, FaceExpressions[]>(\r\n      parentResults,\r\n      this.input,\r\n      async (faces) => Promise.all(faces.map(\r\n        (face) => nets.faceExpressionNet.predictExpressions(face) as Promise<FaceExpressions>,\r\n      )),\r\n      this.extractedFaces,\r\n    );\r\n\r\n    return parentResults.map(\r\n      (parentResult, i) => extendWithFaceExpressions<TSource>(parentResult, faceExpressionsByFace[i]),\r\n    );\r\n  }\r\n\r\n  withAgeAndGender() {\r\n    return new PredictAllAgeAndGenderTask(this, this.input);\r\n  }\r\n}\r\n\r\nexport class PredictSingleFaceExpressionsTask<\r\n  TSource extends WithFaceDetection<{}>\r\n> extends PredictFaceExpressionsTaskBase<WithFaceExpressions<TSource> | undefined, TSource | undefined> {\r\n  public async run(): Promise<WithFaceExpressions<TSource> | undefined> {\r\n    const parentResult = await this.parentTask;\r\n    if (!parentResult) {\r\n      return undefined;\r\n    }\r\n\r\n    const faceExpressions = await extractSingleFaceAndComputeResult<TSource, FaceExpressions>(\r\n      parentResult,\r\n      this.input,\r\n      (face) => nets.faceExpressionNet.predictExpressions(face) as Promise<FaceExpressions>,\r\n      this.extractedFaces,\r\n    );\r\n\r\n    return extendWithFaceExpressions(parentResult, faceExpressions);\r\n  }\r\n\r\n  withAgeAndGender() {\r\n    return new PredictSingleAgeAndGenderTask(this, this.input);\r\n  }\r\n}\r\n\r\nexport class PredictAllFaceExpressionsWithFaceAlignmentTask<\r\n  TSource extends WithFaceLandmarks<WithFaceDetection<{}>>\r\n> extends PredictAllFaceExpressionsTask<TSource> {\r\n  withAgeAndGender() {\r\n    return new PredictAllAgeAndGenderWithFaceAlignmentTask(this, this.input);\r\n  }\r\n\r\n  withFaceDescriptors() {\r\n    return new ComputeAllFaceDescriptorsTask(this, this.input);\r\n  }\r\n}\r\n\r\nexport class PredictSingleFaceExpressionsWithFaceAlignmentTask<\r\n  TSource extends WithFaceLandmarks<WithFaceDetection<{}>>\r\n> extends PredictSingleFaceExpressionsTask<TSource> {\r\n  withAgeAndGender() {\r\n    return new PredictSingleAgeAndGenderWithFaceAlignmentTask(this, this.input);\r\n  }\r\n\r\n  withFaceDescriptor() {\r\n    return new ComputeSingleFaceDescriptorTask(this, this.input);\r\n  }\r\n}\r\n", "/* eslint-disable max-classes-per-file */\r\nimport * as tf from '../../dist/tfjs.esm';\r\n\r\nimport { AgeAndGenderPrediction } from '../ageGenderNet/types';\r\nimport { TNetInput } from '../dom/index';\r\nimport { extendWithAge, WithAge } from '../factories/WithAge';\r\nimport { WithFaceDetection } from '../factories/WithFaceDetection';\r\nimport { WithFaceLandmarks } from '../factories/WithFaceLandmarks';\r\nimport { extendWithGender, WithGender } from '../factories/WithGender';\r\nimport { ComposableTask } from './ComposableTask';\r\nimport { ComputeAllFaceDescriptorsTask, ComputeSingleFaceDescriptorTask } from './ComputeFaceDescriptorsTasks';\r\nimport { extractAllFacesAndComputeResults, extractSingleFaceAndComputeResult } from './extractFacesAndComputeResults';\r\nimport { nets } from './nets';\r\nimport {\r\n  PredictAllFaceExpressionsTask,\r\n  PredictAllFaceExpressionsWithFaceAlignmentTask,\r\n  PredictSingleFaceExpressionsTask,\r\n  PredictSingleFaceExpressionsWithFaceAlignmentTask,\r\n} from './PredictFaceExpressionsTask';\r\n\r\nexport class PredictAgeAndGenderTaskBase<TReturn, TParentReturn> extends ComposableTask<TReturn> {\r\n  constructor(\r\n    // eslint-disable-next-line no-unused-vars\r\n    protected parentTask: ComposableTask<TParentReturn> | Promise<TParentReturn>,\r\n    // eslint-disable-next-line no-unused-vars\r\n    protected input: TNetInput,\r\n    // eslint-disable-next-line no-unused-vars\r\n    protected extractedFaces?: Array<HTMLCanvasElement | tf.Tensor3D>,\r\n  ) {\r\n    super();\r\n  }\r\n}\r\n\r\nexport class PredictAllAgeAndGenderTask<\r\n  TSource extends WithFaceDetection<{}>\r\n> extends PredictAgeAndGenderTaskBase<WithAge<WithGender<TSource>>[], TSource[]> {\r\n  public async run(): Promise<WithAge<WithGender<TSource>>[]> {\r\n    const parentResults = await this.parentTask;\r\n\r\n    const ageAndGenderByFace = await extractAllFacesAndComputeResults<TSource, AgeAndGenderPrediction[]>(\r\n      parentResults,\r\n      this.input,\r\n      async (faces) => Promise.all(faces.map(\r\n        (face) => nets.ageGenderNet.predictAgeAndGender(face) as Promise<AgeAndGenderPrediction>,\r\n      )),\r\n      this.extractedFaces,\r\n    );\r\n\r\n    return parentResults.map((parentResult, i) => {\r\n      const { age, gender, genderProbability } = ageAndGenderByFace[i];\r\n      return extendWithAge(extendWithGender(parentResult, gender, genderProbability), age);\r\n    });\r\n  }\r\n\r\n  withFaceExpressions() {\r\n    return new PredictAllFaceExpressionsTask(this, this.input);\r\n  }\r\n}\r\n\r\nexport class PredictSingleAgeAndGenderTask<\r\n  TSource extends WithFaceDetection<{}>\r\n> extends PredictAgeAndGenderTaskBase<WithAge<WithGender<TSource>> | undefined, TSource | undefined> {\r\n  public async run(): Promise<WithAge<WithGender<TSource>> | undefined> {\r\n    const parentResult = await this.parentTask;\r\n    if (!parentResult) {\r\n      return undefined;\r\n    }\r\n\r\n    const { age, gender, genderProbability } = await extractSingleFaceAndComputeResult<TSource, AgeAndGenderPrediction>(\r\n      parentResult,\r\n      this.input,\r\n      (face) => nets.ageGenderNet.predictAgeAndGender(face) as Promise<AgeAndGenderPrediction>,\r\n      this.extractedFaces,\r\n    );\r\n\r\n    return extendWithAge(extendWithGender(parentResult, gender, genderProbability), age);\r\n  }\r\n\r\n  withFaceExpressions() {\r\n    return new PredictSingleFaceExpressionsTask(this, this.input);\r\n  }\r\n}\r\n\r\nexport class PredictAllAgeAndGenderWithFaceAlignmentTask<\r\n  TSource extends WithFaceLandmarks<WithFaceDetection<{}>>\r\n> extends PredictAllAgeAndGenderTask<TSource> {\r\n  withFaceExpressions() {\r\n    return new PredictAllFaceExpressionsWithFaceAlignmentTask(this, this.input);\r\n  }\r\n\r\n  withFaceDescriptors() {\r\n    return new ComputeAllFaceDescriptorsTask(this, this.input);\r\n  }\r\n}\r\n\r\nexport class PredictSingleAgeAndGenderWithFaceAlignmentTask<\r\n  TSource extends WithFaceLandmarks<WithFaceDetection<{}>>\r\n> extends PredictSingleAgeAndGenderTask<TSource> {\r\n  withFaceExpressions() {\r\n    return new PredictSingleFaceExpressionsWithFaceAlignmentTask(this, this.input);\r\n  }\r\n\r\n  withFaceDescriptor() {\r\n    return new ComputeSingleFaceDescriptorTask(this, this.input);\r\n  }\r\n}\r\n", "/* eslint-disable max-classes-per-file */\r\nimport { TNetInput } from '../dom/index';\r\nimport { extendWithFaceDescriptor, WithFaceDescriptor } from '../factories/WithFaceDescriptor';\r\nimport { WithFaceDetection } from '../factories/WithFaceDetection';\r\nimport { WithFaceLandmarks } from '../factories/WithFaceLandmarks';\r\nimport { ComposableTask } from './ComposableTask';\r\nimport { extractAllFacesAndComputeResults, extractSingleFaceAndComputeResult } from './extractFacesAndComputeResults';\r\nimport { nets } from './nets';\r\nimport {\r\n  PredictAllAgeAndGenderWithFaceAlignmentTask,\r\n  PredictSingleAgeAndGenderWithFaceAlignmentTask,\r\n} from './PredictAgeAndGenderTask';\r\nimport {\r\n  PredictAllFaceExpressionsWithFaceAlignmentTask,\r\n  PredictSingleFaceExpressionsWithFaceAlignmentTask,\r\n} from './PredictFaceExpressionsTask';\r\n\r\nexport class ComputeFaceDescriptorsTaskBase<TReturn, TParentReturn> extends ComposableTask<TReturn> {\r\n  constructor(\r\n    // eslint-disable-next-line no-unused-vars\r\n    protected parentTask: ComposableTask<TParentReturn> | Promise<TParentReturn>,\r\n    // eslint-disable-next-line no-unused-vars\r\n    protected input: TNetInput,\r\n  ) {\r\n    super();\r\n  }\r\n}\r\n\r\nexport class ComputeAllFaceDescriptorsTask<\r\n  TSource extends WithFaceLandmarks<WithFaceDetection<{}>>\r\n> extends ComputeFaceDescriptorsTaskBase<WithFaceDescriptor<TSource>[], TSource[]> {\r\n  public async run(): Promise<WithFaceDescriptor<TSource>[]> {\r\n    const parentResults = await this.parentTask;\r\n\r\n    const descriptors = await extractAllFacesAndComputeResults<TSource, Float32Array[]>(\r\n      parentResults,\r\n      this.input,\r\n      (faces) => Promise.all(faces.map((face) => nets.faceRecognitionNet.computeFaceDescriptor(face) as Promise<Float32Array>)),\r\n      null,\r\n      (parentResult) => parentResult.landmarks.align(null, { useDlibAlignment: true }),\r\n    );\r\n\r\n    return descriptors.map((descriptor, i) => extendWithFaceDescriptor<TSource>(parentResults[i], descriptor));\r\n  }\r\n\r\n  withFaceExpressions() {\r\n    return new PredictAllFaceExpressionsWithFaceAlignmentTask(this, this.input);\r\n  }\r\n\r\n  withAgeAndGender() {\r\n    return new PredictAllAgeAndGenderWithFaceAlignmentTask(this, this.input);\r\n  }\r\n}\r\n\r\nexport class ComputeSingleFaceDescriptorTask<\r\n  TSource extends WithFaceLandmarks<WithFaceDetection<{}>>\r\n> extends ComputeFaceDescriptorsTaskBase<WithFaceDescriptor<TSource> | undefined, TSource | undefined> {\r\n  public async run(): Promise<WithFaceDescriptor<TSource> | undefined> {\r\n    const parentResult = await this.parentTask;\r\n    if (!parentResult) {\r\n      return undefined;\r\n    }\r\n    const descriptor = await extractSingleFaceAndComputeResult<TSource, Float32Array>(\r\n      parentResult,\r\n      this.input,\r\n      (face) => nets.faceRecognitionNet.computeFaceDescriptor(face) as Promise<Float32Array>,\r\n      null,\r\n      // eslint-disable-next-line no-shadow\r\n      (parentResult) => parentResult.landmarks.align(null, { useDlibAlignment: true }),\r\n    );\r\n\r\n    return extendWithFaceDescriptor(parentResult, descriptor);\r\n  }\r\n\r\n  withFaceExpressions() {\r\n    return new PredictSingleFaceExpressionsWithFaceAlignmentTask(this, this.input);\r\n  }\r\n\r\n  withAgeAndGender() {\r\n    return new PredictSingleAgeAndGenderWithFaceAlignmentTask(this, this.input);\r\n  }\r\n}\r\n", "/* eslint-disable max-classes-per-file */\r\nimport { FaceDetection } from '../classes/FaceDetection';\r\nimport { TNetInput } from '../dom/index';\r\nimport { extendWithFaceDetection, WithFaceDetection } from '../factories/WithFaceDetection';\r\nimport { SsdMobilenetv1Options } from '../ssdMobilenetv1/SsdMobilenetv1Options';\r\nimport { TinyFaceDetectorOptions } from '../tinyFaceDetector/TinyFaceDetectorOptions';\r\nimport { TinyYolov2Options } from '../tinyYolov2/index';\r\nimport { ComposableTask } from './ComposableTask';\r\nimport { DetectAllFaceLandmarksTask, DetectSingleFaceLandmarksTask } from './DetectFaceLandmarksTasks';\r\nimport { nets } from './nets';\r\nimport { PredictAllAgeAndGenderTask, PredictSingleAgeAndGenderTask } from './PredictAgeAndGenderTask';\r\nimport { PredictAllFaceExpressionsTask, PredictSingleFaceExpressionsTask } from './PredictFaceExpressionsTask';\r\nimport { FaceDetectionOptions } from './types';\r\n\r\nexport class DetectFacesTaskBase<TReturn> extends ComposableTask<TReturn> {\r\n  constructor(\r\n    // eslint-disable-next-line no-unused-vars\r\n    protected input: TNetInput,\r\n    // eslint-disable-next-line no-unused-vars\r\n    protected options: FaceDetectionOptions = new SsdMobilenetv1Options(),\r\n  ) {\r\n    super();\r\n  }\r\n}\r\n\r\nexport class DetectAllFacesTask extends DetectFacesTaskBase<FaceDetection[]> {\r\n  public async run(): Promise<FaceDetection[]> {\r\n    const { input, options } = this;\r\n\r\n    // eslint-disable-next-line no-nested-ternary\r\n    const faceDetectionFunction = options instanceof TinyFaceDetectorOptions\r\n      // eslint-disable-next-line no-shadow\r\n      ? (input: TNetInput) => nets.tinyFaceDetector.locateFaces(input, options)\r\n      : (\r\n        // eslint-disable-next-line no-nested-ternary\r\n        options instanceof SsdMobilenetv1Options\r\n          // eslint-disable-next-line no-shadow\r\n          ? (input: TNetInput) => nets.ssdMobilenetv1.locateFaces(input, options)\r\n          : (\r\n            options instanceof TinyYolov2Options\r\n              // eslint-disable-next-line no-shadow\r\n              ? (input: TNetInput) => nets.tinyYolov2.locateFaces(input, options)\r\n              : null\r\n          )\r\n      );\r\n\r\n    if (!faceDetectionFunction) {\r\n      throw new Error('detectFaces - expected options to be instance of TinyFaceDetectorOptions | SsdMobilenetv1Options | MtcnnOptions | TinyYolov2Options');\r\n    }\r\n\r\n    return faceDetectionFunction(input);\r\n  }\r\n\r\n  private runAndExtendWithFaceDetections(): Promise<WithFaceDetection<{}>[]> {\r\n    // eslint-disable-next-line no-async-promise-executor\r\n    return new Promise<WithFaceDetection<{}>[]>(async (resolve) => {\r\n      const detections = await this.run();\r\n      resolve(detections.map((detection) => extendWithFaceDetection({}, detection)));\r\n    });\r\n  }\r\n\r\n  withFaceLandmarks(useTinyLandmarkNet: boolean = false) {\r\n    return new DetectAllFaceLandmarksTask(\r\n      this.runAndExtendWithFaceDetections(),\r\n      this.input,\r\n      useTinyLandmarkNet,\r\n    );\r\n  }\r\n\r\n  withFaceExpressions() {\r\n    return new PredictAllFaceExpressionsTask(\r\n      this.runAndExtendWithFaceDetections(),\r\n      this.input,\r\n    );\r\n  }\r\n\r\n  withAgeAndGender() {\r\n    return new PredictAllAgeAndGenderTask(\r\n      this.runAndExtendWithFaceDetections(),\r\n      this.input,\r\n    );\r\n  }\r\n}\r\n\r\nexport class DetectSingleFaceTask extends DetectFacesTaskBase<FaceDetection | undefined> {\r\n  public async run(): Promise<FaceDetection | undefined> {\r\n    const faceDetections = await new DetectAllFacesTask(this.input, this.options);\r\n    let faceDetectionWithHighestScore = faceDetections[0];\r\n    faceDetections.forEach((faceDetection) => {\r\n      if (faceDetection.score > faceDetectionWithHighestScore.score) {\r\n        faceDetectionWithHighestScore = faceDetection;\r\n      }\r\n    });\r\n    return faceDetectionWithHighestScore;\r\n  }\r\n\r\n  private runAndExtendWithFaceDetection(): Promise<WithFaceDetection<{}> | undefined> {\r\n    // eslint-disable-next-line no-async-promise-executor\r\n    return new Promise<WithFaceDetection<{}> | undefined>(async (resolve) => {\r\n      const detection = await this.run();\r\n      resolve(detection ? extendWithFaceDetection<{}>({}, detection) : undefined);\r\n    });\r\n  }\r\n\r\n  withFaceLandmarks(useTinyLandmarkNet: boolean = false) {\r\n    return new DetectSingleFaceLandmarksTask(\r\n      this.runAndExtendWithFaceDetection(),\r\n      this.input,\r\n      useTinyLandmarkNet,\r\n    );\r\n  }\r\n\r\n  withFaceExpressions() {\r\n    return new PredictSingleFaceExpressionsTask(\r\n      this.runAndExtendWithFaceDetection(),\r\n      this.input,\r\n    );\r\n  }\r\n\r\n  withAgeAndGender() {\r\n    return new PredictSingleAgeAndGenderTask(\r\n      this.runAndExtendWithFaceDetection(),\r\n      this.input,\r\n    );\r\n  }\r\n}\r\n", "import { TNetInput } from '../dom/index';\r\nimport { SsdMobilenetv1Options } from '../ssdMobilenetv1/SsdMobilenetv1Options';\r\nimport { DetectAllFacesTask, DetectSingleFaceTask } from './DetectFacesTasks';\r\nimport { FaceDetectionOptions } from './types';\r\n\r\nexport function detectSingleFace(\r\n  input: TNetInput,\r\n  options: FaceDetectionOptions = new SsdMobilenetv1Options(),\r\n): DetectSingleFaceTask {\r\n  return new DetectSingleFaceTask(input, options);\r\n}\r\n\r\nexport function detectAllFaces(\r\n  input: TNetInput,\r\n  options: FaceDetectionOptions = new SsdMobilenetv1Options(),\r\n): DetectAllFacesTask {\r\n  return new DetectAllFacesTask(input, options);\r\n}\r\n", "import { TNetInput } from '../dom/index';\r\nimport { WithFaceDescriptor, WithFaceDetection, WithFaceLandmarks } from '../factories/index';\r\nimport { SsdMobilenetv1Options } from '../ssdMobilenetv1/index';\r\nimport { ITinyYolov2Options, TinyYolov2Options } from '../tinyYolov2/index';\r\nimport { detectAllFaces } from './detectFaces';\r\n\r\n// export allFaces API for backward compatibility\r\n\r\nexport async function allFacesSsdMobilenetv1(\r\n  input: TNetInput,\r\n  minConfidence?: number,\r\n): Promise<WithFaceDescriptor<WithFaceLandmarks<WithFaceDetection<{}>>>[]> {\r\n  return detectAllFaces(input, new SsdMobilenetv1Options(minConfidence ? { minConfidence } : {}))\r\n    .withFaceLandmarks()\r\n    .withFaceDescriptors();\r\n}\r\n\r\nexport async function allFacesTinyYolov2(\r\n  input: TNetInput,\r\n  forwardParams: ITinyYolov2Options = {},\r\n): Promise<WithFaceDescriptor<WithFaceLandmarks<WithFaceDetection<{}>>>[]> {\r\n  return detectAllFaces(input, new TinyYolov2Options(forwardParams))\r\n    .withFaceLandmarks()\r\n    .withFaceDescriptors();\r\n}\r\n\r\nexport const allFaces = allFacesSsdMobilenetv1;\r\n", "export function euclideanDistance(arr1: number[] | Float32Array, arr2: number[] | Float32Array) {\r\n  if (arr1.length !== arr2.length) throw new Error('euclideanDistance: arr1.length !== arr2.length');\r\n\r\n  const desc1 = Array.from(arr1);\r\n  const desc2 = Array.from(arr2);\r\n\r\n  return Math.sqrt(\r\n    desc1\r\n      .map((val, i) => val - desc2[i])\r\n      .reduce((res, diff) => res + (diff ** 2), 0),\r\n  );\r\n}\r\n", "import { FaceMatch } from '../classes/FaceMatch';\r\nimport { LabeledFaceDescriptors } from '../classes/LabeledFaceDescriptors';\r\nimport { euclideanDistance } from '../euclideanDistance';\r\nimport { WithFaceDescriptor } from '../factories/index';\r\n\r\nexport class FaceMatcher {\r\n  private _labeledDescriptors: LabeledFaceDescriptors[]\r\n\r\n  private _distanceThreshold: number\r\n\r\n  constructor(\r\n    inputs: LabeledFaceDescriptors | WithFaceDescriptor<any> | Float32Array | Array<LabeledFaceDescriptors | WithFaceDescriptor<any> | Float32Array>,\r\n    distanceThreshold: number = 0.6,\r\n  ) {\r\n    this._distanceThreshold = distanceThreshold;\r\n\r\n    const inputArray = Array.isArray(inputs) ? inputs : [inputs];\r\n\r\n    if (!inputArray.length) {\r\n      throw new Error('FaceRecognizer.constructor - expected atleast one input');\r\n    }\r\n\r\n    let count = 1;\r\n    const createUniqueLabel = () => `person ${count++}`;\r\n\r\n    this._labeledDescriptors = inputArray.map((desc) => {\r\n      if (desc instanceof LabeledFaceDescriptors) {\r\n        return desc;\r\n      }\r\n\r\n      if (desc instanceof Float32Array) {\r\n        return new LabeledFaceDescriptors(createUniqueLabel(), [desc]);\r\n      }\r\n\r\n      if (desc.descriptor && desc.descriptor instanceof Float32Array) {\r\n        return new LabeledFaceDescriptors(createUniqueLabel(), [desc.descriptor]);\r\n      }\r\n\r\n      throw new Error('FaceRecognizer.constructor - expected inputs to be of type LabeledFaceDescriptors | WithFaceDescriptor<any> | Float32Array | Array<LabeledFaceDescriptors | WithFaceDescriptor<any> | Float32Array>');\r\n    });\r\n  }\r\n\r\n  public get labeledDescriptors(): LabeledFaceDescriptors[] { return this._labeledDescriptors; }\r\n\r\n  public get distanceThreshold(): number { return this._distanceThreshold; }\r\n\r\n  public computeMeanDistance(queryDescriptor: Float32Array, descriptors: Float32Array[]): number {\r\n    return descriptors\r\n      .map((d) => euclideanDistance(d, queryDescriptor))\r\n      .reduce((d1, d2) => d1 + d2, 0)\r\n        / (descriptors.length || 1);\r\n  }\r\n\r\n  public matchDescriptor(queryDescriptor: Float32Array): FaceMatch {\r\n    return this.labeledDescriptors\r\n      .map(({ descriptors, label }) => new FaceMatch(\r\n        label,\r\n        this.computeMeanDistance(queryDescriptor, descriptors),\r\n      ))\r\n      .reduce((best, curr) => (best.distance < curr.distance ? best : curr));\r\n  }\r\n\r\n  public findBestMatch(queryDescriptor: Float32Array): FaceMatch {\r\n    const bestMatch = this.matchDescriptor(queryDescriptor);\r\n    return bestMatch.distance < this.distanceThreshold\r\n      ? bestMatch\r\n      : new FaceMatch('unknown', bestMatch.distance);\r\n  }\r\n\r\n  public toJSON(): any {\r\n    return {\r\n      distanceThreshold: this.distanceThreshold,\r\n      labeledDescriptors: this.labeledDescriptors.map((ld) => ld.toJSON()),\r\n    };\r\n  }\r\n\r\n  public static fromJSON(json: any): FaceMatcher {\r\n    const labeledDescriptors = json.labeledDescriptors\r\n      .map((ld: any) => LabeledFaceDescriptors.fromJSON(ld));\r\n    return new FaceMatcher(labeledDescriptors, json.distanceThreshold);\r\n  }\r\n}\r\n", "import { TinyFaceDetector } from './TinyFaceDetector';\r\n\r\nexport * from './TinyFaceDetector';\r\nexport * from './TinyFaceDetectorOptions';\r\n\r\nexport function createTinyFaceDetector(weights: Float32Array) {\r\n  const net = new TinyFaceDetector();\r\n  net.extractWeights(weights);\r\n  return net;\r\n}\r\n", "import { Dimensions, IDimensions } from './classes/index';\r\nimport { FaceDetection } from './classes/FaceDetection';\r\nimport { FaceLandmarks } from './classes/FaceLandmarks';\r\nimport { extendWithFaceDetection, isWithFaceDetection } from './factories/WithFaceDetection';\r\nimport { extendWithFaceLandmarks, isWithFaceLandmarks } from './factories/WithFaceLandmarks';\r\n\r\nexport function resizeResults<T>(results: T, dimensions: IDimensions): T {\r\n  const { width, height } = new Dimensions(dimensions.width, dimensions.height);\r\n\r\n  if (width <= 0 || height <= 0) {\r\n    throw new Error(`resizeResults - invalid dimensions: ${JSON.stringify({ width, height })}`);\r\n  }\r\n\r\n  if (Array.isArray(results)) {\r\n    // return results.map(obj => resizeResults(obj, { width, height })) as any as T\r\n    return (results as Array<any>).map((obj) => resizeResults(obj, { width, height } as IDimensions)) as any as T;\r\n  }\r\n\r\n  if (isWithFaceLandmarks(results)) {\r\n    const resizedDetection = results.detection.forSize(width, height);\r\n    const resizedLandmarks = results.unshiftedLandmarks.forSize(resizedDetection.box.width, resizedDetection.box.height);\r\n    return extendWithFaceLandmarks(extendWithFaceDetection(results, resizedDetection), resizedLandmarks);\r\n  }\r\n\r\n  if (isWithFaceDetection(results)) {\r\n    return extendWithFaceDetection(results, results.detection.forSize(width, height));\r\n  }\r\n\r\n  if (results instanceof FaceLandmarks || results instanceof FaceDetection) {\r\n    return (results as any).forSize(width, height);\r\n  }\r\n\r\n  return results;\r\n}\r\n"],
  "mappings": "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",
  "names": []
}
